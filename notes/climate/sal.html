<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-11-12">

<title>Saharan Air Layer (SAL) – re:current_analytics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/favicon.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-4be685f768d06aff641a2dc379f1fc59.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<!-- Plausible analytics -->
<script defer="" data-domain="recurrentanalytics.com" src="https://plausible.io/js/script.js"></script>

<!-- D3.js for network graph -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<!-- Code output styling for all pages with code -->
<style>
/* Prevent scrolling in code output areas */
.cell-output,
.cell-output-stdout,
.cell-output-display,
.cell-output-error,
.cell-output-warning {
  overflow: visible !important;
  max-height: none !important;
  white-space: pre-wrap;
  word-wrap: break-word;
}

pre.sourceCode,
pre code {
  overflow: visible !important;
  max-height: none !important;
}

/* Ensure output containers don't scroll */
.cell-output > pre,
.cell-output-stdout > pre {
  overflow: visible !important;
  max-height: none !important;
}

/* Better spacing and layout for code cells */
.cell {
  margin: 2rem 0;
}

.cell-code {
  margin-bottom: 0.5rem;
}

/* Text output styling - blue bar on left for ALL text outputs */
.cell-output-stdout,
.cell-output:not(.cell-output-display):not(.cell-output-error):not(.cell-output-warning) {
  margin-top: 0.75rem;
  padding: 1rem;
  background: var(--bs-tertiary-bg, #f8f9fa);
  border-radius: 0.375rem;
  border-left: 3px solid var(--bs-primary, #0d6efd);
}

.cell-output-stdout pre,
.cell-output:not(.cell-output-display):not(.cell-output-error):not(.cell-output-warning) pre {
  margin: 0;
  padding: 0;
  background: transparent;
  border: none;
  font-size: 0.9rem;
  line-height: 1.6;
}

/* Visual output styling - better stacking */
.cell-output-display {
  margin-top: 1rem;
  margin-bottom: 0;
}

.cell-output-display figure {
  margin: 0;
  padding: 0;
}

.cell-output-display .figure-img,
.cell-output-display img,
.cell-output-display figure img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 0 auto;
  border-radius: 0.375rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.cell-output-display .figure-img:hover,
.cell-output-display img:hover,
.cell-output-display figure img:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Lightbox modal for enlarged images */
.figure-lightbox {
  display: none;
  position: fixed;
  z-index: 10000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(4px);
  animation: fadeIn 0.2s ease;
}

.figure-lightbox.active {
  display: flex;
  align-items: center;
  justify-content: center;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.figure-lightbox-content {
  position: relative;
  max-width: 95%;
  max-height: 95vh;
  overflow: auto;
  animation: zoomIn 0.2s ease;
}

@keyframes zoomIn {
  from { transform: scale(0.9); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

.figure-lightbox-img {
  max-width: 100%;
  max-height: 95vh;
  width: auto;
  height: auto;
  display: block;
  border-radius: 0.375rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}

.figure-lightbox-close {
  position: absolute;
  top: -2.5rem;
  right: 0;
  background: rgba(255, 255, 255, 0.2);
  border: 2px solid rgba(255, 255, 255, 0.3);
  color: white;
  font-size: 2rem;
  width: 2.5rem;
  height: 2.5rem;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  line-height: 1;
  padding: 0;
}

.figure-lightbox-close:hover {
  background: rgba(0, 0, 0, 0.8);
}

.figure-lightbox-close:focus {
  outline: 2px solid white;
  outline-offset: 2px;
}

@media (max-width: 768px) {
  .figure-lightbox-content {
    max-width: 98%;
  }
  
  .figure-lightbox-close {
    top: 1rem;
    right: 1rem;
  }
}

/* Better separation between code and output */
.cell-code + .cell-output {
  margin-top: 0.75rem;
}

/* Error output styling */
.cell-output-error {
  margin-top: 0.75rem;
  padding: 1rem;
  background: var(--bs-danger-bg-subtle, #f8d7da);
  border-radius: 0.375rem;
  border-left: 3px solid var(--bs-danger, #dc3545);
  color: var(--bs-danger-text-emphasis, #721c24);
}

.cell-output-error pre {
  margin: 0;
  padding: 0;
  background: transparent;
  border: none;
}
</style>
<script>
// Lightbox functionality for all pages with code
document.addEventListener('DOMContentLoaded', function() {
  // Create lightbox container
  const lightbox = document.createElement('div');
  lightbox.className = 'figure-lightbox';
  lightbox.innerHTML = `
    <div class="figure-lightbox-content">
      <button class="figure-lightbox-close" aria-label="Close">&times;</button>
      <img class="figure-lightbox-img" src="" alt="Enlarged figure">
    </div>
  `;
  document.body.appendChild(lightbox);
  
  const lightboxImg = lightbox.querySelector('.figure-lightbox-img');
  const lightboxClose = lightbox.querySelector('.figure-lightbox-close');
  
  // Make all figure images clickable
  function makeImagesClickable() {
    document.querySelectorAll('.cell-output-display .figure-img, .cell-output-display img, .cell-output-display figure img').forEach(img => {
      if (!img.hasAttribute('data-lightbox-processed')) {
        img.style.cursor = 'pointer';
        img.setAttribute('title', 'Click to enlarge');
        img.setAttribute('data-lightbox-processed', 'true');
        
        img.addEventListener('click', function(e) {
          e.stopPropagation();
          lightboxImg.src = this.src;
          lightboxImg.alt = this.alt || 'Enlarged figure';
          lightbox.classList.add('active');
          document.body.style.overflow = 'hidden';
        });
      }
    });
  }
  
  // Initial setup
  makeImagesClickable();
  
  // Watch for new images added dynamically
  const imageObserver = new MutationObserver(function(mutations) {
    makeImagesClickable();
  });
  
  imageObserver.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  // Close lightbox
  function closeLightbox() {
    lightbox.classList.remove('active');
    document.body.style.overflow = '';
  }
  
  lightboxClose.addEventListener('click', closeLightbox);
  
  lightbox.addEventListener('click', function(e) {
    if (e.target === lightbox) {
      closeLightbox();
    }
  });
  
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && lightbox.classList.contains('active')) {
      closeLightbox();
    }
  });
});
</script>

<!-- Hero drift effect -->
<style>
  .rac-hero {
    position: relative; padding: 5rem 0 4rem; text-align:center;
    overflow: hidden;
  }
  .rac-hero h1 { font-weight: 800; letter-spacing: .5px; }
  .rac-hero .drift {
    position: absolute; left: -10%; right:-10%; bottom: -40px; height: 120px;
    background: radial-gradient(100% 60% at 50% 40%, var(--bs-secondary-bg) 0%, transparent 70%);
    animation: slowfloat 14s ease-in-out infinite alternate;
    opacity:.7; filter: blur(10px);
  }
  @keyframes slowfloat { from { transform: translateY(0px);} to {transform: translateY(16px);} }
</style>

<!-- Reading progress bar, keyboard shortcuts, random note -->
<script src="assets/graph-script.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOMContentLoaded fired - graph script starting');
  
  // Reading progress bar
  const progressBar = document.createElement('div');
  progressBar.className = 'reading-progress';
  document.body.appendChild(progressBar);
  
  window.addEventListener('scroll', function() {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
    progressBar.style.width = progress + '%';
  });

  // Keyboard shortcuts
  const noteLinks = Array.from(document.querySelectorAll('.quarto-listing-default a, .sidebar-item a'));
  let currentIndex = -1;

  document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // / to focus search
    if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
      e.preventDefault();
      const searchInput = document.querySelector('#quarto-search input, .aa-Input');
      if (searchInput) searchInput.focus();
    }
    
    // j/k to navigate notes (on listing pages)
    if (noteLinks.length > 0) {
      if (e.key === 'j') {
        currentIndex = Math.min(currentIndex + 1, noteLinks.length - 1);
        noteLinks[currentIndex]?.focus();
      }
      if (e.key === 'k') {
        currentIndex = Math.max(currentIndex - 1, 0);
        noteLinks[currentIndex]?.focus();
      }
    }
    
    // ? to show keyboard hints
    if (e.key === '?') {
      const hint = document.querySelector('.keyboard-hint');
      if (hint) hint.classList.toggle('visible');
    }
  });

  // Add keyboard hint element
  const hint = document.createElement('div');
  hint.className = 'keyboard-hint';
  hint.innerHTML = '/ search · j/k navigate · ? hints';
  document.body.appendChild(hint);


  // Reading time - add to article pages
  const articleBody = document.querySelector('.quarto-title-block, #quarto-document-content');
  const contentArea = document.querySelector('#quarto-document-content, .content, main');
  if (articleBody && contentArea) {
    const text = contentArea.innerText || '';
    const wordCount = text.trim().split(/\s+/).length;
    const readingTime = Math.max(1, Math.ceil(wordCount / 200));
    const timeSpan = document.createElement('span');
    timeSpan.className = 'reading-time';
    timeSpan.textContent = readingTime + ' min read';
    const titleMeta = document.querySelector('.quarto-title-meta, .quarto-title');
    if (titleMeta) {
      titleMeta.appendChild(document.createTextNode(' · '));
      titleMeta.appendChild(timeSpan);
    }
  }


  // Network Graph - Obsidian-style visualization
  // Nodes auto-generated from search index, links manually curated
  let graphData = {
    nodes: [],
    links: [
      // Manual link definitions - can be enhanced with auto-detection later
      { source: 'home', target: 'notes' },
      { source: 'home', target: 'work' },
      { source: 'home', target: 'reading' },
      { source: 'home', target: 'about' },
      { source: 'notes', target: 'hello' },
      { source: 'notes', target: 'monte-carlo' },
      { source: 'notes', target: 'sal' },
      { source: 'notes', target: 'risk-1' },
      { source: 'risk-1', target: 'monte-carlo' },
      { source: 'risk-1', target: 'risk-2' },
      { source: 'risk-2', target: 'risk-1' },
      { source: 'risk-2', target: 'risk-3' },
      { source: 'risk-2', target: 'sal' },
      { source: 'risk-2', target: 'heatwave' },
      { source: 'risk-3', target: 'risk-1' },
      { source: 'risk-3', target: 'risk-2' },
      { source: 'risk-3', target: 'monte-carlo' },
      { source: 'risk-3', target: 'sal' },
      { source: 'work', target: 'heatwave' },
      { source: 'heatwave', target: 'sal' },
      { source: 'heatwave', target: 'risk-2' },
      { source: 'sal', target: 'heatwave' },
      { source: 'monte-carlo', target: 'risk-3' }
    ]
  };
  
  // Auto-generate graph nodes from search index
  fetch('/search.json')
    .then(res => res.json())
    .then(searchData => {
      const nodeMap = new Map();
      
      // Core navigation pages
      const coreNodes = [
        { id: 'home', label: 'Home', path: '/', cat: 'nav' },
        { id: 'about', label: 'About', path: '/about.html', cat: 'nav' },
        { id: 'notes', label: 'Notes', path: '/notes/', cat: 'nav' },
        { id: 'work', label: 'Work', path: '/work/', cat: 'nav' },
        { id: 'reading', label: 'Reading', path: '/reading/', cat: 'nav' },
        { id: 'contact', label: 'Contact', path: '/contact_cv.html', cat: 'nav' }
      ];
      
      coreNodes.forEach(node => {
        nodeMap.set(node.path, node);
      });
      
      // Extract pages from search index
      searchData.forEach(item => {
        const path = '/' + item.href.split('#')[0];
        if (!nodeMap.has(path) && !path.includes('index.html')) {
          // Determine category from path
          let cat = 'nav';
          if (path.startsWith('/notes/')) cat = 'notes';
          else if (path.startsWith('/work/')) cat = 'work';
          else if (path.startsWith('/reading/')) cat = 'reading';
          
          // Create ID from path (sanitize for graph)
          const id = path.replace(/[\/\.]/g, '-').replace(/^-|-$/g, '').replace(/html$/g, '');
          
          nodeMap.set(path, {
            id: id,
            label: item.title || path.split('/').pop(),
            path: path,
            cat: cat
          });
        }
      });
      
      graphData.nodes = Array.from(nodeMap.values());
      
      // Simple, reliable auto-generation based on structure
      console.log('Auto-generating graph links based on structure...');
      const autoLinks = [];
      
      // 1. Connect all notes to notes index
      const notesNodes = graphData.nodes.filter(n => n.cat === 'notes');
      const notesIndexNode = graphData.nodes.find(n => n.path === '/notes/' || n.path === '/notes/index.html');
      if (notesIndexNode) {
        notesNodes.forEach(note => {
          if (note.id !== notesIndexNode.id) {
            autoLinks.push({ source: note.id, target: notesIndexNode.id });
          }
        });
      }
      
      // 2. Connect notes in same subdirectory (e.g., climate/)
      notesNodes.forEach(note1 => {
        notesNodes.forEach(note2 => {
          if (note1.id !== note2.id) {
            const note1Dir = note1.path.split('/').slice(0, -1).join('/');
            const note2Dir = note2.path.split('/').slice(0, -1).join('/');
            if (note1Dir === note2Dir && note1Dir !== '/notes' && note1Dir.length > 6) {
              if (!autoLinks.find(l => l.source === note1.id && l.target === note2.id)) {
                autoLinks.push({ source: note1.id, target: note2.id });
              }
            }
          }
        });
      });
      
      // 3. Connect notes in same series (e.g., risk-series-1, risk-series-2, risk-series-3)
      notesNodes.forEach(note1 => {
        notesNodes.forEach(note2 => {
          if (note1.id !== note2.id) {
            // Extract base name (remove numbers/suffixes)
            const name1 = note1.path.replace(/-\d+$/, '').replace(/part-\d+/i, '').replace(/series-\d+/i, '');
            const name2 = note2.path.replace(/-\d+$/, '').replace(/part-\d+/i, '').replace(/series-\d+/i, '');
            if (name1 === name2 && name1.length > 10) { // Only if meaningful match
              if (!autoLinks.find(l => l.source === note1.id && l.target === note2.id)) {
                autoLinks.push({ source: note1.id, target: note2.id });
              }
            }
          }
        });
      });
      
      // 4. Connect work to work index
      const workNodes = graphData.nodes.filter(n => n.cat === 'work');
      const workIndexNode = graphData.nodes.find(n => n.path === '/work/' || n.path === '/work/index.html');
      if (workIndexNode) {
        workNodes.forEach(workItem => {
          if (workItem.id !== workIndexNode.id) {
            autoLinks.push({ source: workItem.id, target: workIndexNode.id });
          }
        });
      }
      
      // Merge with manual links
      const manualLinks = graphData.links;
      const mergedLinks = [...manualLinks];
      autoLinks.forEach(autoLink => {
        if (!mergedLinks.find(l => l.source === autoLink.source && l.target === autoLink.target)) {
          mergedLinks.push(autoLink);
        }
      });
      
      graphData.links = mergedLinks;
      console.log(`Generated ${autoLinks.length} structural links, total links: ${mergedLinks.length}`);
      
      // Re-render with new links
      createSidebarGraph();
      renderMiniGraph();
      graphInitialized = false;
      
      // Generate backlinks and related content after graph data is ready
      injectBacklinksAndRelated();
      
      // Ensure sidebar graph container exists
      createSidebarGraph();
      
      // Initial render (will be empty, but container will be ready)
      renderMiniGraph();
      
      // Reset graph initialization flag so modal graph can be re-initialized with new data
      graphInitialized = false;
    })
    .catch(err => {
      console.error('Failed to load search index for graph', err);
      // Fallback to minimal core nodes
      graphData.nodes = [
        { id: 'home', label: 'Home', path: '/', cat: 'nav' },
        { id: 'about', label: 'About', path: '/about.html', cat: 'nav' },
        { id: 'notes', label: 'Notes', path: '/notes/', cat: 'nav' },
        { id: 'work', label: 'Work', path: '/work/', cat: 'nav' },
        { id: 'reading', label: 'Reading', path: '/reading/', cat: 'nav' },
        { id: 'contact', label: 'Contact', path: '/contact_cv.html', cat: 'nav' }
      ];
      createSidebarGraph();
      renderMiniGraph();
    });
  
  // Category colors for graph nodes
  const catColors = {
    nav: 'var(--bs-secondary)',
    notes: 'var(--bs-info)',
    work: 'var(--bs-success)',
    reading: 'var(--bs-warning)'
  };

  // Create sidebar mini-graph widget
  // ALWAYS create it - on ALL pages, regardless of sidebar existence
  function createSidebarGraph() {
    const existingContainer = document.getElementById('mini-graph-container');
    
    // If graph already exists and is in a valid location, just ensure it's visible
    if (existingContainer) {
      const existingGraph = existingContainer.closest('.sidebar-graph');
      if (existingGraph && existingGraph.parentElement) {
        // Graph exists - check if it needs to be moved to sidebar
        let sidebar = document.querySelector('#quarto-margin-sidebar');
        if (!sidebar) sidebar = document.querySelector('.quarto-sidebar');
        if (!sidebar) sidebar = document.querySelector('.sidebar');
        if (!sidebar) sidebar = document.querySelector('#TOC');
        if (!sidebar) sidebar = document.querySelector('#quarto-toc');
        if (!sidebar) sidebar = document.querySelector('.quarto-listing');
        if (!sidebar) sidebar = document.querySelector('[role="complementary"]');
        if (!sidebar) sidebar = document.querySelector('nav[role="doc-toc"]');
        if (!sidebar) sidebar = document.querySelector('aside');
        
        // If sidebar exists and graph is not in it, move it there
        if (sidebar && !sidebar.contains(existingGraph)) {
          sidebar.insertBefore(existingGraph, sidebar.firstChild);
          console.log('Moved existing graph to sidebar:', sidebar.className || sidebar.id);
        }
        // Ensure it's visible
        existingGraph.style.display = 'block';
        existingGraph.style.visibility = 'visible';
        existingGraph.style.opacity = '1';
        return;
      }
    }
    
    // Create new graph widget - ALWAYS create it
    const sidebarGraph = document.createElement('div');
    sidebarGraph.className = 'sidebar-graph';
    sidebarGraph.title = 'Click to expand';
    sidebarGraph.innerHTML = `
      <div class="sidebar-graph-header">
        <span class="sidebar-graph-title">Connections</span>
        <span class="sidebar-graph-expand">expand</span>
      </div>
      <div class="sidebar-graph-container" id="mini-graph-container"></div>
    `;
    
    // Try to find sidebar (in order of preference) - more comprehensive search
    let sidebar = document.querySelector('#quarto-margin-sidebar');
    if (!sidebar) sidebar = document.querySelector('.quarto-sidebar');
    if (!sidebar) sidebar = document.querySelector('.sidebar');
    if (!sidebar) sidebar = document.querySelector('#TOC');
    if (!sidebar) sidebar = document.querySelector('#quarto-toc');
    if (!sidebar) sidebar = document.querySelector('nav[role="doc-toc"]');
    if (!sidebar) sidebar = document.querySelector('.quarto-listing');
    if (!sidebar) sidebar = document.querySelector('[role="complementary"]');
    if (!sidebar) sidebar = document.querySelector('aside');
    
    // Also try to find any element with TOC-related classes
    if (!sidebar) {
      const tocElements = document.querySelectorAll('[class*="toc"], [class*="TOC"], [id*="toc"], [id*="TOC"]');
      for (let el of tocElements) {
        if (el.offsetParent !== null) { // Element is visible
          sidebar = el;
          break;
        }
      }
    }
    
    if (sidebar) {
      // Insert at the top of sidebar
      try {
        sidebar.insertBefore(sidebarGraph, sidebar.firstChild);
        console.log('Created sidebar graph widget in sidebar:', sidebar.className || sidebar.id || 'found');
      } catch (e) {
        // If insertBefore fails, try appendChild
        sidebar.appendChild(sidebarGraph);
        console.log('Created sidebar graph widget in sidebar (appended):', sidebar.className || sidebar.id);
      }
    } else {
      // No sidebar found - try to insert at top of main content area
      const mainContent = document.querySelector('#quarto-document-content, main, .content, article, .quarto-content, .page-columns, .column-body');
      if (mainContent) {
        try {
          mainContent.insertBefore(sidebarGraph, mainContent.firstChild);
          console.log('Created sidebar graph widget at top of main content');
        } catch (e) {
          mainContent.appendChild(sidebarGraph);
          console.log('Created sidebar graph widget in main content (appended)');
        }
      } else {
        // Last resort: fixed position widget (always visible)
        document.body.appendChild(sidebarGraph);
        sidebarGraph.style.position = 'fixed';
        sidebarGraph.style.bottom = '4rem';
        sidebarGraph.style.right = '1rem';
        sidebarGraph.style.width = '200px';
        sidebarGraph.style.zIndex = '100';
        console.log('Created sidebar graph widget as fixed element (no sidebar or main content found)');
      }
    }
  }
  
  // Aggressively try to create graph - multiple times to catch all page types
  createSidebarGraph();
  setTimeout(createSidebarGraph, 50);
  setTimeout(createSidebarGraph, 100);
  setTimeout(createSidebarGraph, 250);
  setTimeout(createSidebarGraph, 500);
  setTimeout(createSidebarGraph, 1000);
  setTimeout(createSidebarGraph, 2000);
  setTimeout(createSidebarGraph, 3000);
  setTimeout(createSidebarGraph, 5000);
  
  // Aggressive MutationObserver to catch ALL DOM changes
  const observer = new MutationObserver(function(mutations) {
    const hasContainer = document.getElementById('mini-graph-container');
    if (!hasContainer) {
      createSidebarGraph();
    } else {
      // Graph exists - ensure it's in the right place
      const graph = document.querySelector('.sidebar-graph');
      if (graph) {
        // Try all possible sidebar selectors
        let sidebar = document.querySelector('#quarto-margin-sidebar, .quarto-sidebar, .sidebar, #TOC, #quarto-toc, nav[role="doc-toc"], [role="complementary"], aside');
        if (sidebar && !sidebar.contains(graph)) {
          createSidebarGraph();
        }
      }
    }
  });
  
  // Observe everything - body, documentElement, and common content containers
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  observer.observe(document.documentElement, {
    childList: true,
    subtree: true
  });
  
  // Also watch for main content area
  const mainObserver = new MutationObserver(function() {
    const hasContainer = document.getElementById('mini-graph-container');
    if (!hasContainer) {
      createSidebarGraph();
    }
  });
  
  // Watch for main content appearing
  const checkMainContent = setInterval(function() {
    const mainContent = document.querySelector('#quarto-document-content, main, .content, article');
    if (mainContent) {
      const hasContainer = document.getElementById('mini-graph-container');
      if (!hasContainer) {
        createSidebarGraph();
      }
      clearInterval(checkMainContent);
    }
  }, 100);
  
  // Stop checking after 10 seconds
  setTimeout(function() {
    clearInterval(checkMainContent);
  }, 10000);

  // Create modal with controls
  const graphModal = document.createElement('div');
  graphModal.className = 'graph-modal-overlay';
  graphModal.innerHTML = `
    <div class="graph-modal">
      <div class="graph-modal-header">
        <span class="graph-modal-title">Note Connections</span>
        <div class="graph-modal-controls">
          <input type="text" class="graph-search-input" id="graph-search-input" placeholder="Search nodes..." autocomplete="off">
          <div class="graph-category-filters">
            <button class="graph-filter-btn active" data-cat="all" title="Show all">All</button>
            <button class="graph-filter-btn active" data-cat="notes" title="Toggle notes">Notes</button>
            <button class="graph-filter-btn active" data-cat="work" title="Toggle work">Work</button>
            <button class="graph-filter-btn active" data-cat="reading" title="Toggle reading">Reading</button>
            <button class="graph-filter-btn active" data-cat="nav" title="Toggle navigation">Nav</button>
          </div>
          <button class="graph-control-btn" id="focus-mode-btn" title="Show only connected nodes">Focus</button>
          <button class="graph-control-btn" id="reset-zoom-btn" title="Reset zoom">Reset</button>
          <button class="graph-modal-close">&times;</button>
        </div>
      </div>
      <div class="graph-container" id="graph-container"></div>
    </div>
  `;
  document.body.appendChild(graphModal);
  
  // Category filter state
  const activeCategories = new Set(['all', 'notes', 'work', 'reading', 'nav']);
  let searchQuery = '';
  let focusedNodeIndex = -1;
  let keyboardFocusableNodes = [];
  
  // Track recent pages (from localStorage)
  function getRecentPages() {
    try {
      const recent = localStorage.getItem('graph-recent-pages');
      return recent ? JSON.parse(recent) : [];
    } catch {
      return [];
    }
  }
  
  function addRecentPage(path) {
    try {
      let recent = getRecentPages();
      recent = recent.filter(p => p.path !== path);
      recent.unshift({ path: path, timestamp: Date.now() });
      recent = recent.slice(0, 10); // Keep last 10
      localStorage.setItem('graph-recent-pages', JSON.stringify(recent));
    } catch {}
  }
  
  // Mark current page as visited
  addRecentPage(window.location.pathname);
  const recentPages = getRecentPages().map(p => p.path);

  function getCurrentPageId() {
    const path = window.location.pathname;
    console.log('Current path:', path);
    console.log('Available nodes:', graphData.nodes.map(n => ({id: n.id, path: n.path})));
    
    // Try exact match first
    let node = graphData.nodes.find(n => path === n.path || path === n.path + 'index.html');
    
    // Try ends-with match (for paths like /notes/ matching /notes/index.html)
    if (!node) {
      node = graphData.nodes.find(n => {
        if (path.endsWith('/') && n.path === path) return true;
        if (n.path.endsWith('/') && path.startsWith(n.path)) return true;
        if (path.endsWith(n.path) || n.path.endsWith(path)) return true;
        return false;
      });
    }
    
    // Handle homepage
    if (!node && (path === '/' || path === '/index.html' || path.endsWith('/index.html'))) {
      node = graphData.nodes.find(n => n.path === '/' || n.id === 'home');
    }
    
    console.log('Found current node:', node ? node.id : 'NOT FOUND');
    return node ? node.id : null;
  }

  function openGraph() {
    graphModal.classList.add('active');
    initGraph();
  }

  function closeGraph() {
    graphModal.classList.remove('active');
  }

  // Add click handler to sidebar graph (using event delegation since element might be created later)
  document.addEventListener('click', function(e) {
    if (e.target.closest('.sidebar-graph')) {
      openGraph();
    }
    // Handle modal close
    if (e.target === graphModal || e.target.classList.contains('graph-modal-close')) {
      closeGraph();
    }
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && graphModal.classList.contains('active')) closeGraph();
    if (e.key === 'g' && !e.ctrlKey && !e.metaKey && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
      openGraph();
    }
  });

  // Render mini-graph in sidebar immediately using D3-force
  function renderMiniGraph() {
    const container = document.getElementById('mini-graph-container');
    if (!container) {
      console.warn('Graph container not found, creating...');
      createSidebarGraph();
      // Try again after creating
      setTimeout(renderMiniGraph, 100);
      return;
    }
    if (typeof d3 === 'undefined') {
      console.warn('D3.js not loaded yet, will retry...');
      setTimeout(renderMiniGraph, 500);
      return;
    }
    if (!graphData.nodes || graphData.nodes.length === 0) {
      console.log('Graph data not loaded yet, nodes:', (graphData.nodes && graphData.nodes.length) || 0, '- will render when data loads');
      // Don't return - still create container so it's visible
      container.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--bs-secondary); font-size: 0.8rem;">Loading connections...</div>';
      return;
    }
    
    console.log('Rendering graph with', graphData.nodes.length, 'nodes');
    
    // Clear container before rendering
    container.innerHTML = '';
    
    const width = container.clientWidth || 180;
    const height = container.clientHeight || 150;
    const currentId = getCurrentPageId();

    const svg = d3.select(container).append('svg')
      .attr('viewBox', `0 0 ${width} ${height}`);

    const nodes = graphData.nodes.map(d => ({...d}));
    const links = graphData.links.map(d => ({source: d.source, target: d.target})).filter(l => {
      // Only include links where both source and target nodes exist
      return nodes.find(n => n.id === l.source) && nodes.find(n => n.id === l.target);
    });

    const connectedNodes = new Set();
    graphData.links.forEach(l => {
      if (l.source === currentId || l.target === currentId) {
        connectedNodes.add(l.source);
        connectedNodes.add(l.target);
      }
    });

    // Find current page node and center on it
    const currentNode = nodes.find(n => n.id === currentId);
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Pin current node to center BEFORE simulation
    if (currentNode) {
      currentNode.x = centerX;
      currentNode.y = centerY;
      currentNode.fx = centerX; // Fixed position
      currentNode.fy = centerY;
    }
    
    // D3 force simulation for mini graph - center on current page
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id(d => d.id).distance(30))
      .force('charge', d3.forceManyBody().strength(-60))
      .force('center', d3.forceCenter(centerX, centerY))
      .force('collision', d3.forceCollide().radius(10));
      
    // Pin current node to center with strong force
    if (currentNode) {
      simulation.force('x', d3.forceX(centerX).strength(d => d.id === currentId ? 1.0 : 0.05));
      simulation.force('y', d3.forceY(centerY).strength(d => d.id === currentId ? 1.0 : 0.05));
    }
    
    simulation.stop();

    // Run simulation synchronously for static layout (more iterations for better centering)
    for (let i = 0; i < 150; i++) simulation.tick();
    
    // Ensure current node stays at center
    if (currentNode) {
      currentNode.x = centerX;
      currentNode.y = centerY;
      currentNode.fx = centerX;
      currentNode.fy = centerY;
    }

    // Clamp positions (but not current node)
    nodes.forEach(n => {
      if (n.id !== currentId) {
        n.x = Math.max(15, Math.min(width - 15, n.x));
        n.y = Math.max(15, Math.min(height - 15, n.y));
      }
    });

    // Draw links
    svg.selectAll('line')
      .data(links)
      .join('line')
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y)
      .attr('class', d => 'graph-link' + (connectedNodes.has(d.source.id) && connectedNodes.has(d.target.id) ? ' connected' : ''));

    // Draw nodes with hover tooltip
    const nodeGroups = svg.selectAll('g.mini-node')
      .data(nodes)
      .join('g')
      .attr('class', 'mini-node')
      .attr('transform', d => `translate(${d.x},${d.y})`);

    nodeGroups.append('circle')
      .attr('r', d => d.id === currentId ? 6 : (connectedNodes.has(d.id) ? 4 : 3))
      .attr('fill', d => d.id === currentId ? 'var(--bs-primary)' : (catColors[d.cat] || 'var(--bs-secondary)'))
      .attr('class', d => 'graph-node' + (d.id === currentId ? ' current' : ''));

    // Tooltip on hover
    const tooltip = d3.select(container).append('div')
      .attr('class', 'mini-graph-tooltip')
      .style('opacity', 0);

    nodeGroups
      .on('mouseenter', (event, d) => {
        tooltip.text(d.label)
          .style('left', (d.x + 10) + 'px')
          .style('top', (d.y - 5) + 'px')
          .style('opacity', 1);
      })
      .on('mouseleave', () => tooltip.style('opacity', 0));
  }
  
  // Initial render (will be empty, but container will be ready)
  createSidebarGraph();
  renderMiniGraph();

  // Mobile floating graph button (always visible)
  console.log('Creating mobile graph button...');
  const mobileGraphBtn = document.createElement('button');
  mobileGraphBtn.className = 'mobile-graph-btn';
  mobileGraphBtn.innerHTML = '&#x1F578;'; // spider web emoji as graph icon
  mobileGraphBtn.title = 'View connections (or press g)';
  mobileGraphBtn.setAttribute('aria-label', 'Open connection graph');
  mobileGraphBtn.addEventListener('click', function(e) {
    e.preventDefault();
    console.log('Graph button clicked!');
    openGraph();
  });
  document.body.appendChild(mobileGraphBtn);
  console.log('Mobile graph button added to body', mobileGraphBtn);

  let graphInitialized = false;
  let graphZoom = null;
  let focusMode = false;
  
  function initGraph() {
    if (typeof d3 === 'undefined' || !graphData.nodes || graphData.nodes.length === 0) return;

    const container = document.getElementById('graph-container');
    if (!container) return;
    
    // Clear container before rendering
    container.innerHTML = '';
    
    const width = container.clientWidth;
    const height = container.clientHeight;
    const currentId = getCurrentPageId();

    // Calculate node degrees (connections) for sizing
    const nodeDegrees = new Map();
    graphData.nodes.forEach(n => nodeDegrees.set(n.id, 0));
    graphData.links.forEach(l => {
      nodeDegrees.set(l.source, (nodeDegrees.get(l.source) || 0) + 1);
      nodeDegrees.set(l.target, (nodeDegrees.get(l.target) || 0) + 1);
    });

    // Calculate connected nodes first
    const connectedNodes = new Set();
    if (currentId) {
      graphData.links.forEach(l => {
        if (l.source === currentId || l.target === currentId) {
          connectedNodes.add(l.source);
          connectedNodes.add(l.target);
        }
      });
    }

    // Filter nodes based on focus mode and category filters
    let nodes = graphData.nodes.map(d => ({
      ...d,
      degree: nodeDegrees.get(d.id) || 0
    }));
    
    // Apply category filter
    if (!activeCategories.has('all')) {
      nodes = nodes.filter(n => activeCategories.has(n.cat));
    }
    
    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      nodes = nodes.filter(n => 
        n.label.toLowerCase().includes(query) || 
        n.path.toLowerCase().includes(query) ||
        n.id.toLowerCase().includes(query)
      );
    }
    
    // Apply focus mode filter
    if (focusMode && currentId) {
      nodes = nodes.filter(n => connectedNodes.has(n.id));
    }
    
    // Store for keyboard navigation
    keyboardFocusableNodes = nodes;
    
    // Filter links to only include filtered nodes
    const links = graphData.links.map(d => ({source: d.source, target: d.target})).filter(l => {
      const sourceExists = nodes.find(n => n.id === l.source);
      const targetExists = nodes.find(n => n.id === l.target);
      return sourceExists && targetExists;
    });

    // Create SVG with zoom container
    const svg = d3.select(container).append('svg')
      .attr('width', width)
      .attr('height', height);
      
    const g = svg.append('g');

    // Find current page node and center on it
    const currentGraphNode = nodes.find(n => n.id === currentId);
    const graphCenterX = width / 2;
    const graphCenterY = height / 2;
    
    // Pin current node to center BEFORE simulation
    if (currentGraphNode) {
      currentGraphNode.x = graphCenterX;
      currentGraphNode.y = graphCenterY;
      currentGraphNode.fx = graphCenterX; // Fixed position
      currentGraphNode.fy = graphCenterY;
    }
    
    // D3 force simulation for full graph - center on current page
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id(d => d.id).distance(80))
      .force('charge', d3.forceManyBody().strength(-200))
      .force('center', d3.forceCenter(graphCenterX, graphCenterY))
      .force('collision', d3.forceCollide().radius(25));
      
    // Pin current node to center with strong force
    if (currentGraphNode) {
      simulation.force('x', d3.forceX(graphCenterX).strength(d => d.id === currentId ? 1.0 : 0.05));
      simulation.force('y', d3.forceY(graphCenterY).strength(d => d.id === currentId ? 1.0 : 0.05));
    }
    
    simulation.stop();

    // Run simulation synchronously (more iterations for better centering)
    for (let i = 0; i < 200; i++) simulation.tick();
    
    // Ensure current node stays at center
    if (currentGraphNode) {
      currentGraphNode.x = graphCenterX;
      currentGraphNode.y = graphCenterY;
      currentGraphNode.fx = graphCenterX;
      currentGraphNode.fy = graphCenterY;
    }

    // Clamp positions (but not current node)
    nodes.forEach(n => {
      if (n.id !== currentId) {
        n.x = Math.max(50, Math.min(width - 50, n.x));
        n.y = Math.max(50, Math.min(height - 50, n.y));
      }
    });

    // Calculate node sizes based on degree (connections)
    const maxDegree = Math.max(...nodes.map(n => n.degree), 1);
    const minRadius = 6;
    const maxRadius = 16;
    const currentRadius = 18;
    
    function getRadius(d) {
      if (d.id === currentId) return currentRadius;
      // Size based on degree: minRadius + (degree/maxDegree) * (maxRadius - minRadius)
      const size = minRadius + (d.degree / maxDegree) * (maxRadius - minRadius);
      return Math.max(minRadius, Math.min(maxRadius, size));
    }

    // Draw links (with transitions)
    g.selectAll('line')
      .data(links, d => `${d.source.id}-${d.target.id}`)
      .join(
        enter => {
          const line = enter.append('line')
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.source.x)
            .attr('y2', d => d.source.y)
            .style('opacity', 0);
          line.transition().duration(300)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y)
            .style('opacity', 1);
          return line;
        },
        update => {
          update.transition().duration(300)
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
          return update;
        },
        exit => {
          exit.transition().duration(300)
            .style('opacity', 0)
            .remove();
          return exit;
        }
      )
      .attr('class', d => 'graph-link' + (connectedNodes.has(d.source.id) && connectedNodes.has(d.target.id) ? ' connected' : ''));

    // Draw nodes with labels (with transitions)
    const nodeGroups = g.selectAll('g.graph-node')
      .data(nodes, d => d.id)
      .join(
        enter => {
          const g = enter.append('g')
            .attr('class', d => 'graph-node' + (d.id === currentId ? ' current' : ''))
            .attr('data-node-id', d => d.id)
            .attr('transform', d => `translate(${d.x},${d.y})`)
            .style('opacity', 0);
          g.transition().duration(300).style('opacity', 1);
          return g;
        },
        update => {
          update.transition().duration(300)
            .attr('transform', d => `translate(${d.x},${d.y})`);
          return update;
        },
        exit => {
          exit.transition().duration(300)
            .style('opacity', 0)
            .remove();
          return exit;
        }
      )
      .attr('class', d => 'graph-node' + (d.id === currentId ? ' current' : '') + 
        (focusedNodeIndex >= 0 && keyboardFocusableNodes[focusedNodeIndex]?.id === d.id ? ' keyboard-focused' : ''))
      .style('cursor', 'pointer')
      .on('click', (event, d) => { window.location.href = d.path; });

    nodeGroups.append('circle')
      .attr('r', getRadius)
      .attr('fill', d => {
        if (d.id === currentId) return 'var(--bs-primary)';
        // Check if recently visited
        const isRecent = recentPages.includes(d.path);
        return isRecent ? 'var(--bs-warning)' : (catColors[d.cat] || 'var(--bs-secondary)');
      })
      .attr('class', d => {
        let classes = [];
        if (d.id === currentId) classes.push('current');
        if (recentPages.includes(d.path)) classes.push('recent');
        return classes.join(' ');
      });

    nodeGroups.append('text')
      .attr('y', d => getRadius(d) + 14)
      .text(d => d.label);
      
    // Hover preview tooltip
    const previewTooltip = d3.select(container).append('div')
      .attr('class', 'graph-preview-tooltip')
      .style('opacity', 0)
      .style('pointer-events', 'none');
      
    nodeGroups
      .on('mouseenter', function(event, d) {
        // Fetch page data for preview
        fetch(d.path)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Extract preview data
            const title = doc.querySelector('h1, .quarto-title h1, title')?.textContent || d.label;
            const description = doc.querySelector('meta[name="description"]')?.getAttribute('content') || 
                              doc.querySelector('p')?.textContent?.substring(0, 150) || '';
            const readingTime = doc.querySelector('.reading-time')?.textContent || '';
            
            // Position tooltip
            const [x, y] = d3.pointer(event, container);
            previewTooltip
              .html(`
                <div class="preview-title">${title}</div>
                ${description ? `<div class="preview-description">${description}${description.length >= 150 ? '...' : ''}</div>` : ''}
                ${readingTime ? `<div class="preview-meta">${readingTime}</div>` : ''}
                <div class="preview-path">${d.path}</div>
              `)
              .style('left', (x + 15) + 'px')
              .style('top', (y - 10) + 'px')
              .style('opacity', 1);
          })
          .catch(() => {
            // Fallback if fetch fails
            const [x, y] = d3.pointer(event, container);
            previewTooltip
              .html(`
                <div class="preview-title">${d.label}</div>
                <div class="preview-path">${d.path}</div>
              `)
              .style('left', (x + 15) + 'px')
              .style('top', (y - 10) + 'px')
              .style('opacity', 1);
          });
      })
      .on('mouseleave', () => {
        previewTooltip.style('opacity', 0);
      })
      .on('mousemove', function(event) {
        const [x, y] = d3.pointer(event, container);
        previewTooltip
          .style('left', (x + 15) + 'px')
          .style('top', (y - 10) + 'px');
      });
      
    // Add zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.3, 3])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
      
    svg.call(zoom);
    graphZoom = zoom;
    
    // Reset zoom to fit
    const bounds = g.node().getBBox();
    const fullWidth = bounds.width;
    const fullHeight = bounds.height;
    const midX = bounds.x + fullWidth / 2;
    const midY = bounds.y + fullHeight / 2;
    
    if (fullWidth && fullHeight) {
      const scale = Math.min(width / fullWidth, height / fullHeight) * 0.9;
      const translate = [width / 2 - scale * midX, height / 2 - scale * midY];
      svg.call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
    }
    
    
    graphInitialized = true;
  }
  
  // Search input handler
  const searchInput = document.getElementById('graph-search-input');
  if (searchInput) {
    searchInput.addEventListener('input', function(e) {
      searchQuery = e.target.value.trim();
      focusedNodeIndex = -1; // Reset focus when searching
      graphInitialized = false;
      initGraph();
    });
    
    // Clear search on Escape
    searchInput.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        e.target.value = '';
        searchQuery = '';
        focusedNodeIndex = -1;
        graphInitialized = false;
        initGraph();
      }
    });
  }
  
  // Category filter handlers
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('graph-filter-btn')) {
      e.preventDefault();
      e.stopPropagation();
      const cat = e.target.getAttribute('data-cat');
      
      if (cat === 'all') {
        // Toggle all
        const allActive = activeCategories.has('all');
        if (allActive) {
          activeCategories.clear();
          activeCategories.add('all');
          document.querySelectorAll('.graph-filter-btn[data-cat]').forEach(btn => {
            if (btn.getAttribute('data-cat') !== 'all') btn.classList.remove('active');
          });
        } else {
          activeCategories.clear();
          activeCategories.add('all', 'notes', 'models', 'projects', 'nav');
          document.querySelectorAll('.graph-filter-btn').forEach(btn => btn.classList.add('active'));
        }
      } else {
        // Toggle individual category
        if (activeCategories.has(cat)) {
          activeCategories.delete(cat);
          activeCategories.delete('all'); // Remove 'all' if any category is deselected
          e.target.classList.remove('active');
        } else {
          activeCategories.add(cat);
          e.target.classList.add('active');
          // If all categories are active, add 'all' back
          const allCats = ['notes', 'work', 'reading', 'nav'];
          if (allCats.every(c => activeCategories.has(c))) {
            activeCategories.add('all');
            document.querySelector('.graph-filter-btn[data-cat="all"]')?.classList.add('active');
          }
        }
      }
      
      graphInitialized = false;
      initGraph();
    }
    
    if (e.target.id === 'focus-mode-btn') {
      e.preventDefault();
      e.stopPropagation();
      focusMode = !focusMode;
      e.target.textContent = focusMode ? 'Show All' : 'Focus';
      e.target.classList.toggle('active', focusMode);
      graphInitialized = false;
      initGraph();
    }
    if (e.target.id === 'reset-zoom-btn') {
      e.preventDefault();
      e.stopPropagation();
      const container = document.getElementById('graph-container');
      if (container && graphZoom) {
        const svg = d3.select(container).select('svg');
        svg.transition().duration(750).call(
          graphZoom.transform,
          d3.zoomIdentity
        );
      }
    }
  });
  
  // Keyboard navigation
  document.addEventListener('keydown', function(e) {
    if (!graphModal.classList.contains('active')) return;
    if (e.target.tagName === 'INPUT' && e.target.id !== 'graph-search-input') return;
    
    // Don't interfere with search input typing
    if (e.target.id === 'graph-search-input' && e.key !== 'ArrowDown' && e.key !== 'ArrowUp' && e.key !== 'Enter' && e.key !== 'Escape') {
      return;
    }
    
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      e.preventDefault();
      
      if (keyboardFocusableNodes.length === 0) return;
      
      // Move focus
      if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
        focusedNodeIndex = Math.min(focusedNodeIndex + 1, keyboardFocusableNodes.length - 1);
      } else {
        focusedNodeIndex = Math.max(focusedNodeIndex - 1, 0);
      }
      
      // Highlight focused node and center on it
      const focusedNode = keyboardFocusableNodes[focusedNodeIndex];
      if (focusedNode) {
        graphInitialized = false;
        initGraph();
        
        // Center on focused node after render
        setTimeout(() => {
          const container = document.getElementById('graph-container');
          if (container && graphZoom) {
            const svg = d3.select(container).select('svg');
            const g = svg.select('g');
            const nodeElement = g.select(`g.graph-node[data-node-id="${focusedNode.id}"]`);
            if (!nodeElement.empty()) {
              const transform = d3.zoomTransform(svg.node());
              const node = focusedNode;
              const x = -node.x * transform.k + container.clientWidth / 2;
              const y = -node.y * transform.k + container.clientHeight / 2;
              svg.transition().duration(300).call(
                graphZoom.transform,
                d3.zoomIdentity.translate(x, y).scale(transform.k)
              );
            }
          }
        }, 100);
      }
    } else if (e.key === 'Enter' && focusedNodeIndex >= 0) {
      e.preventDefault();
      const focusedNode = keyboardFocusableNodes[focusedNodeIndex];
      if (focusedNode) {
        window.location.href = focusedNode.path;
      }
    }
  });

  // Phase 1: Auto-generate Backlinks and Related Content
  function injectBacklinksAndRelated() {
    // Wait for graph data to be available
    if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
      setTimeout(injectBacklinksAndRelated, 500);
      return;
    }

    const currentPath = window.location.pathname;
    const currentId = getCurrentPageId();
    
    // Skip homepage - no related content needed
    if (!currentPath || currentPath === '/' || currentPath === '/index.html') return;
    
    if (!currentId) return; // Skip if we can't identify current page

    // Find backlinks (pages that link TO this page)
    const backlinks = [];
    graphData.links.forEach(link => {
      if (typeof link.target === 'string' && link.target === currentId) {
        const sourceNode = graphData.nodes.find(n => n.id === link.source);
        if (sourceNode && sourceNode.path !== currentPath) {
          backlinks.push(sourceNode);
        }
      } else if (typeof link.target === 'object' && link.target.id === currentId) {
        const sourceNode = typeof link.source === 'string' 
          ? graphData.nodes.find(n => n.id === link.source)
          : link.source;
        if (sourceNode && sourceNode.path !== currentPath) {
          backlinks.push(sourceNode);
        }
      }
    });

    // Find related content (pages this page links TO)
    const related = [];
    graphData.links.forEach(link => {
      if (typeof link.source === 'string' && link.source === currentId) {
        const targetNode = graphData.nodes.find(n => n.id === link.target);
        if (targetNode && targetNode.path !== currentPath) {
          related.push(targetNode);
        }
      } else if (typeof link.source === 'object' && link.source.id === currentId) {
        const targetNode = typeof link.target === 'string'
          ? graphData.nodes.find(n => n.id === link.target)
          : link.target;
        if (targetNode && targetNode.path !== currentPath) {
          related.push(targetNode);
        }
      }
    });

    // Remove duplicates
    const uniqueBacklinks = Array.from(new Map(backlinks.map(b => [b.path, b])).values());
    const uniqueRelated = Array.from(new Map(related.map(r => [r.path, r])).values());

    // Find insertion point (before footer or at end of content)
    const contentArea = document.querySelector('#quarto-document-content, .content, main');
    if (!contentArea) return;

    // Remove existing backlinks and related sections (both manual and auto-generated)
    const existingBacklinks = contentArea.querySelectorAll('.backlinks, .backlinks-auto');
    const existingRelated = contentArea.querySelectorAll('.related-content, .related-content-auto');
    existingBacklinks.forEach(el => el.remove());
    existingRelated.forEach(el => el.remove());

    // Inject backlinks section
    if (uniqueBacklinks.length > 0) {
      const backlinksDiv = document.createElement('div');
      backlinksDiv.className = 'backlinks backlinks-auto';
      backlinksDiv.innerHTML = `
        <h4>Linked from</h4>
        <ul>
          ${uniqueBacklinks.map(node => `
            <li><a href="${node.path}">${node.label}</a></li>
          `).join('')}
        </ul>
      `;
      
      // Insert before footer or at end
      const footer = contentArea.querySelector('footer, .nav-footer');
      if (footer) {
        contentArea.insertBefore(backlinksDiv, footer);
      } else {
        contentArea.appendChild(backlinksDiv);
      }
    }

    // Inject related content section
    if (uniqueRelated.length > 0) {
      const relatedDiv = document.createElement('div');
      relatedDiv.className = 'related-content related-content-auto';
      relatedDiv.innerHTML = `
        <h4>Related content</h4>
        <ul>
          ${uniqueRelated.map(node => `
            <li><a href="${node.path}">${node.label}</a></li>
          `).join('')}
        </ul>
      `;
      
      // Insert after backlinks or before footer
      const backlinksSection = contentArea.querySelector('.backlinks-auto');
      if (backlinksSection) {
        backlinksSection.insertAdjacentElement('afterend', relatedDiv);
      } else {
        const footer = contentArea.querySelector('footer, .nav-footer');
        if (footer) {
          contentArea.insertBefore(relatedDiv, footer);
        } else {
          contentArea.appendChild(relatedDiv);
        }
      }
    }
  }

  // Backlinks will be initialized after graph data loads (called from graph initialization)

  // Phase 2: Reading Trail / Breadcrumb Navigation
  function injectReadingTrail() {
    const path = window.location.pathname;
    if (path === '/' || path === '/index.html') return; // Skip on homepage

    const pathParts = path.split('/').filter(p => p && p !== 'index.html');
    const breadcrumbs = [{ title: 'Home', path: '/' }];

    // Build breadcrumbs from path
    let currentPath = '';
    pathParts.forEach((part, index) => {
      currentPath += '/' + part;
      const isLast = index === pathParts.length - 1;
      
      // Capitalize and format the part name
      let title = part
        .replace(/-/g, ' ')
        .replace(/\.(html|qmd)$/g, '')
        .split(' ')
        .map(w => w.charAt(0).toUpperCase() + w.slice(1))
        .join(' ');

      // Try to get the actual page title from the document
      if (isLast) {
        const pageTitle = document.querySelector('h1.title, .quarto-title h1, h1')?.textContent?.trim();
        if (pageTitle) title = pageTitle;
      }

      breadcrumbs.push({
        title: title,
        path: currentPath + (isLast ? '' : '/'),
        isLast: isLast
      });
    });

    const contentArea = document.querySelector('#quarto-document-content, .content, main');
    if (!contentArea) return;

    // Remove existing trail
    const existingTrail = contentArea.querySelector('.reading-trail');
    if (existingTrail) existingTrail.remove();

    const trailDiv = document.createElement('nav');
    trailDiv.className = 'reading-trail';
    trailDiv.setAttribute('aria-label', 'Breadcrumb navigation');
    trailDiv.innerHTML = `
      <ol class="breadcrumb">
        ${breadcrumbs.map((crumb, index) => `
          <li class="breadcrumb-item ${crumb.isLast ? 'active' : ''}">
            ${crumb.isLast ? crumb.title : `<a href="${crumb.path}">${crumb.title}</a>`}
          </li>
        `).join('')}
      </ol>
    `;

    // Insert at the top of content
    const firstChild = contentArea.firstElementChild;
    if (firstChild) {
      contentArea.insertBefore(trailDiv, firstChild);
    } else {
      contentArea.appendChild(trailDiv);
    }
  }

  // Initialize Phase 2 features
  setTimeout(() => {
    injectReadingTrail();
  }, 500);

  // Phase 3: Reading Progress Tracking
  const READING_PROGRESS_KEY = 'quarto-reading-progress';
  const MAX_PROGRESS_ITEMS = 50;

  // Track reading progress
  function trackReadingProgress() {
    const currentPath = window.location.pathname;
    if (!currentPath || currentPath === '/' || currentPath === '/index.html') return;

    const contentArea = document.querySelector('#quarto-document-content, .content, main');
    if (!contentArea) return;

    let progress = JSON.parse(localStorage.getItem(READING_PROGRESS_KEY) || '{}');
    
    // Update progress on scroll (throttled)
    let scrollTimeout;
    const updateProgress = () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = scrollHeight > 0 ? Math.round((scrollTop / scrollHeight) * 100) : 0;
        
        progress[currentPath] = {
          percent: scrollPercent,
          scrollTop: scrollTop,
          updatedAt: Date.now(),
          title: document.title.replace(/\s*[–-]\s*.*$/, '').trim()
        };
        
        // Clean old entries (keep only MAX_PROGRESS_ITEMS most recent)
        const entries = Object.entries(progress)
          .sort((a, b) => (b[1].updatedAt || 0) - (a[1].updatedAt || 0))
          .slice(0, MAX_PROGRESS_ITEMS);
        progress = Object.fromEntries(entries);
        
        localStorage.setItem(READING_PROGRESS_KEY, JSON.stringify(progress));
      }, 500);
    };

    window.addEventListener('scroll', updateProgress, { passive: true });
    updateProgress(); // Initial save
  }

  // Restore reading position
  function restoreReadingPosition() {
    const currentPath = window.location.pathname;
    if (!currentPath || currentPath === '/' || currentPath === '/index.html') return;

    const progress = JSON.parse(localStorage.getItem(READING_PROGRESS_KEY) || '{}');
    const pageProgress = progress[currentPath];
    
    if (pageProgress && pageProgress.scrollTop > 100) {
      // Small delay to ensure page is rendered
      setTimeout(() => {
        window.scrollTo({
          top: pageProgress.scrollTop,
          behavior: 'smooth'
        });
        
        // Show a subtle notification
        showProgressNotification(pageProgress.percent);
      }, 300);
    }
  }

  // Show progress notification
  function showProgressNotification(percent) {
    const notification = document.createElement('div');
    notification.className = 'reading-progress-notification';
    notification.innerHTML = `Resumed at ${percent}%`;
    document.body.appendChild(notification);
    
          setTimeout(() => {
      notification.classList.add('show');
    }, 100);
    
          setTimeout(() => {
      notification.classList.remove('show');
      setTimeout(() => notification.remove(), 300);
          }, 2000);
  }

  // Initialize Phase 3 features
  setTimeout(() => {
    trackReadingProgress();
    restoreReadingPosition();
  }, 1000);
});
</script>


<meta property="og:title" content="Saharan Air Layer (SAL) – re:current_analytics">
<meta property="og:description" content="A lab-notebook for climate risk, models, and recurrent intelligence.">
<meta property="og:site_name" content="re:current_analytics">
<meta name="twitter:title" content="Saharan Air Layer (SAL) – re:current_analytics">
<meta name="twitter:description" content="A lab-notebook for climate risk, models, and recurrent intelligence.">
<meta name="twitter:creator" content="@timmwalker">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../assets/favicon.svg" alt="" class="navbar-logo light-content">
    <img src="../../assets/favicon.svg" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">re:current_analytics</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#core-effects" id="toc-core-effects" class="nav-link active" data-scroll-target="#core-effects">Core Effects</a></li>
  <li><a href="#visual-mental-model" id="toc-visual-mental-model" class="nav-link" data-scroll-target="#visual-mental-model">Visual Mental Model</a></li>
  <li><a href="#links" id="toc-links" class="nav-link" data-scroll-target="#links">Links</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/recurrentanalytics/quarto_website/blob/main/notes/climate/sal.md" class="toc-action"><i class="bi bi-github"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Saharan Air Layer (SAL)</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">Climate</div>
    <div class="quarto-category">Tropical Cyclones</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 12, 2025</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">November 14, 2025</p>
    </div>
  </div>
    
  </div>
  


</header>


<p><strong>Key Insight:</strong><br>
A hot, dry, dust-laden air mass moving off North Africa that can suppress Atlantic hurricane formation by increasing vertical wind shear and stabilizing the atmosphere.</p>
<section id="core-effects" class="level2">
<h2 class="anchored" data-anchor-id="core-effects">Core Effects</h2>
<ul>
<li>Dry air entrainment → disrupts convection</li>
<li>Increased shear → weakens cyclone organization</li>
<li>Dust aerosols → affect radiation balance &amp; SST</li>
</ul>
</section>
<section id="visual-mental-model" class="level2">
<h2 class="anchored" data-anchor-id="visual-mental-model">Visual Mental Model</h2>
<p>SAL = “giant desiccating lid” over the Atlantic basin</p>
</section>
<section id="links" class="level2">
<h2 class="anchored" data-anchor-id="links">Links</h2>
<ul>
<li>[[MJO]]</li>
<li>[[African Easterly Waves]]</li>
</ul>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/recurrentanalytics\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Saharan Air Layer (SAL)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 2025-11-12</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [Climate, Tropical Cyclones]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>**Key Insight:**  </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>A hot, dry, dust-laden air mass moving off North Africa that can suppress Atlantic hurricane formation by increasing vertical wind shear and stabilizing the atmosphere.</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="fu">## Core Effects</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Dry air entrainment → disrupts convection</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Increased shear → weakens cyclone organization</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Dust aerosols → affect radiation balance &amp; SST</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="fu">## Visual Mental Model</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>SAL = "giant desiccating lid" over the Atlantic basin</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="fu">## Links</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>[<span class="co">[</span><span class="ot">MJO</span><span class="co">]</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>[<span class="co">[</span><span class="ot">African Easterly Waves</span><span class="co">]</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Timm Walker</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/recurrentanalytics/quarto_website/blob/main/notes/climate/sal.md" class="toc-action"><i class="bi bi-github"></i>View source</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>