{"title":"Climate Extremes Explorer","markdown":{"yaml":{"title":"Climate Extremes Explorer","date":"2025-12-15","categories":["climate","extremes","analysis","visualization"],"description":"Comprehensive interactive analysis of climate extremes using synthetic climate data. Demonstrates methods for identifying, analyzing, and visualizing extreme climate events including heatwaves, cold snaps, and extreme precipitation. Features return period analysis, event clustering, and multi-variable correlation analysis.","execute":{"echo":true,"warning":false,"message":false},"freeze":"auto"},"headingText":"Overview","containsRefs":false,"markdown":"\n\n\nExtreme climate events‚Äîheatwaves, cold snaps, extreme precipitation‚Äîare not anomalies to be dismissed as outliers. They are the signal. Understanding their frequency, intensity, and co-occurrence patterns is fundamental to climate risk assessment. This analysis applies extreme value theory and multivariate statistics to extract structure from what appears chaotic.\n\nThe framework demonstrates:\n\n- **Extreme Event Identification** - Multiple methods (percentile, absolute, anomaly)\n- **Return Period Analysis** - Extreme value theory (Block Maxima, Peaks Over Threshold)\n- **Multi-Variable Correlation** - Relationships between climate variables\n- **Event Clustering** - Hierarchical clustering of extreme events\n- **Statistical Analysis** - Comprehensive extreme event statistics\n\n## Building the Foundation: Synthetic Climate Data\n\nBefore we can identify extremes, we need a baseline. Synthetic data generation here serves two purposes: it provides a controlled environment to test methods, and it demonstrates how realistic climate variability can emerge from relatively simple stochastic processes. The data spans 24 years (2000-2023) with daily resolution, capturing temperature, precipitation, and atmospheric pressure‚Äîthree variables that interact in complex ways.\n\nThe synthetic generation incorporates:\n- **Seasonal cycles** (annual temperature variation, precipitation patterns)\n- **Inter-annual variability** (year-to-year fluctuations)\n- **Cross-variable dependencies** (temperature-precipitation relationships)\n- **Autocorrelation** (weather persistence over days)\n\nThis isn't \"fake data\" in the pejorative sense‚Äîit's a generative model that captures the statistical structure of real climate systems. When we later identify extremes, we're finding events that would be rare under this baseline distribution.\n\n### Generate and Load Climate Data\n\n```{python}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\ntry:\n    import seaborn as sns\n    HAS_SEABORN = True\nexcept ImportError:\n    HAS_SEABORN = False\n    print(\"Note: seaborn not available, using matplotlib for heatmap\")\nfrom scipy import stats\n\nfrom src.climate_extremes import (\n    generate_synthetic_climate_data,\n    identify_extremes,\n    compute_return_periods,\n    analyze_correlations,\n    cluster_extreme_events,\n    compute_extreme_statistics,\n)\n\n# Generate synthetic climate data (2000-2023, daily)\nprint(\"Generating synthetic climate data...\")\nclimate_data = generate_synthetic_climate_data(\n    start_date=\"2000-01-01\",\n    end_date=\"2023-12-31\",\n    freq=\"D\",\n    seed=42\n)\n\nprint(f\"\\nData shape: {climate_data.shape}\")\nprint(f\"Date range: {climate_data['datetime_utc'].min()} to {climate_data['datetime_utc'].max()}\")\nprint(\"\\nFirst few rows:\")\nprint(climate_data.head())\nprint(\"\\nSummary statistics:\")\nprint(climate_data[['temperature_c', 'precipitation_mm', 'pressure_hpa']].describe())\n```\n\n## Defining the Extreme: Operational Thresholds\n\nWhat counts as \"extreme\" is not a question with a single answer. It's a modeling choice with real consequences. We use the 95th percentile threshold‚Äîmeaning 5% of days exceed this value‚Äîbut this is arbitrary. A heatwave that's extreme in one region might be normal in another. A 3-day minimum duration filters out single-day spikes, focusing on sustained events that have greater impact.\n\nThe choice of method matters:\n- **Percentile-based**: Relative to the local distribution (adapts to regional climate)\n- **Absolute thresholds**: Fixed values (e.g., 30¬∞C) that ignore local context\n- **Anomaly-based**: Deviations from expected seasonal patterns\n\nHere, we use percentile thresholds because they're scale-invariant and adapt to the data's inherent variability. A 95th percentile heatwave in a temperate region might be 28¬∞C, while in a desert it might be 42¬∞C‚Äîboth are equally \"extreme\" relative to their contexts.\n\n### Identify Extreme Events\n\n```{python}\n# Identify extreme temperature events (95th percentile, minimum 3 consecutive days)\nclimate_data = identify_extremes(\n    climate_data,\n    variable='temperature_c',\n    method='percentile',\n    threshold=95.0,\n    min_duration=3\n)\n\n# Also identify extreme precipitation events\nclimate_data = identify_extremes(\n    climate_data,\n    variable='precipitation_mm',\n    method='percentile',\n    threshold=95.0,\n    min_duration=1\n)\n\n# Compute statistics\ntemp_stats = compute_extreme_statistics(climate_data, 'temperature_c')\nprecip_stats = compute_extreme_statistics(climate_data, 'precipitation_mm')\n\nprint(\"Temperature Extreme Events:\")\nprint(f\"  Number of events: {temp_stats['n_events']}\")\nprint(f\"  Total extreme days: {temp_stats['total_days']}\")\nprint(f\"  Mean intensity: {temp_stats['mean_intensity']:.2f}¬∞C above threshold\")\nprint(f\"  Maximum intensity: {temp_stats['max_intensity']:.2f}¬∞C above threshold\")\nprint(f\"  Mean duration: {temp_stats['mean_duration']:.1f} days\")\n\nprint(\"\\nPrecipitation Extreme Events:\")\nprint(f\"  Number of events: {precip_stats['n_events']}\")\nprint(f\"  Total extreme days: {precip_stats['total_days']}\")\nprint(f\"  Mean intensity: {precip_stats['mean_intensity']:.2f} mm above threshold\")\nprint(f\"  Maximum intensity: {precip_stats['max_intensity']:.2f} mm above threshold\")\n```\n\n## Temporal Patterns: When Extremes Occur\n\nThe timeline visualization reveals something crucial: extreme events are not uniformly distributed. They cluster in time, creating periods of elevated risk. The temperature extremes show clear seasonal patterns‚Äîheatwaves in summer, cold snaps in winter‚Äîbut also reveal inter-annual variability. Some years are quiet; others are punctuated by multiple extreme events.\n\nThis temporal clustering has implications for risk assessment. If extremes were independent random events, we could model them with simple Poisson processes. But they're not. They exhibit persistence (heatwaves last multiple days) and clustering (extreme years contain multiple extreme events). This means risk is not constant‚Äîit's time-varying and state-dependent.\n\nThe visualization also shows the relationship between variables. Notice how extreme precipitation events sometimes coincide with temperature extremes (convective storms during heatwaves), and sometimes don't (frontal systems during cooler periods). This co-occurrence‚Äîor lack thereof‚Äîmatters for compound risk assessment.\n\n```{python}\n# Create timeline visualization with extreme events highlighted\nfig, axes = plt.subplots(3, 1, figsize=(14, 10), sharex=True)\n\n# Temperature with extreme events\nax1 = axes[0]\nax1.plot(climate_data['datetime_utc'], climate_data['temperature_c'], \n         color='#2c3e50', alpha=0.6, linewidth=0.8, label='Temperature')\nax1.scatter(climate_data[climate_data['is_extreme']]['datetime_utc'],\n           climate_data[climate_data['is_extreme']]['temperature_c'],\n           c='#e74c3c', s=30, alpha=0.7, label='Extreme Events', zorder=5)\nax1.axhline(y=np.percentile(climate_data['temperature_c'], 95), \n           color='#c0392b', linestyle='--', alpha=0.7, label='95th Percentile')\nax1.set_ylabel('Temperature (¬∞C)', fontsize=11, fontweight='bold')\nax1.set_title('Temperature Time Series with Extreme Events Highlighted', \n              fontsize=13, fontweight='bold', pad=10)\nax1.legend(loc='upper left', fontsize=9)\nax1.grid(True, alpha=0.3)\n\n# Precipitation with extreme events\nax2 = axes[1]\nax2.plot(climate_data['datetime_utc'], climate_data['precipitation_mm'], \n         color='#3498db', alpha=0.6, linewidth=0.8, label='Precipitation')\nprecip_extremes = climate_data[climate_data['precipitation_mm'] >= \n                               np.percentile(climate_data['precipitation_mm'], 95)]\nax2.scatter(precip_extremes['datetime_utc'], precip_extremes['precipitation_mm'],\n           c='#2980b9', s=30, alpha=0.7, label='Extreme Events', zorder=5)\nax2.axhline(y=np.percentile(climate_data['precipitation_mm'], 95), \n           color='#21618c', linestyle='--', alpha=0.7, label='95th Percentile')\nax2.set_ylabel('Precipitation (mm)', fontsize=11, fontweight='bold')\nax2.set_title('Precipitation Time Series with Extreme Events Highlighted', \n              fontsize=13, fontweight='bold', pad=10)\nax2.legend(loc='upper left', fontsize=9)\nax2.grid(True, alpha=0.3)\n\n# Pressure\nax3 = axes[2]\nax3.plot(climate_data['datetime_utc'], climate_data['pressure_hpa'], \n         color='#7f8c8d', alpha=0.6, linewidth=0.8)\nax3.set_ylabel('Pressure (hPa)', fontsize=11, fontweight='bold')\nax3.set_xlabel('Date', fontsize=11, fontweight='bold')\nax3.set_title('Atmospheric Pressure Time Series', \n              fontsize=13, fontweight='bold', pad=10)\nax3.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n```\n\n## Return Periods: Quantifying Rarity\n\nReturn period analysis answers a deceptively simple question: \"How often should we expect an event of this magnitude?\" A 100-year return period doesn't mean it happens exactly once per century‚Äîit means the annual probability is 1%. Over a 100-year period, there's a 63% chance of experiencing at least one such event (due to the compounding of probabilities).\n\nThe two methods shown here capture different aspects of extremes:\n- **Block Maxima (Annual Maxima)**: Takes the maximum value each year, fits a Generalized Extreme Value (GEV) distribution. Good for understanding the worst-case scenario in any given year.\n- **Peaks Over Threshold**: Identifies all values above a threshold, fits a Generalized Pareto Distribution (GPD). More data-efficient, captures multiple extremes per year.\n\nThe log-scale x-axis is intentional. Return periods follow a power-law relationship‚Äîdoubling the return period doesn't double the intensity. The curve flattens, meaning truly catastrophic events (1000-year return periods) are only marginally more intense than 100-year events, but exponentially rarer.\n\nThis analysis is the foundation of engineering design standards (dams, bridges, flood defenses) and insurance pricing. The \"100-year flood\" isn't a prediction‚Äîit's a risk metric.\n\n```{python}\n# Compute return periods for temperature extremes\nreturn_periods_temp = compute_return_periods(\n    climate_data,\n    variable='temperature_c',\n    method='block_maxima',\n    block_size='1Y'\n)\n\nreturn_periods_precip = compute_return_periods(\n    climate_data,\n    variable='precipitation_mm',\n    method='peaks_over_threshold',\n)\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Temperature return periods\nax1 = axes[0]\nax1.plot(return_periods_temp['return_period_years'], \n        return_periods_temp['return_value'], \n        marker='o', linewidth=2, markersize=8, color='#e74c3c')\nax1.set_xlabel('Return Period (years)', fontsize=11, fontweight='bold')\nax1.set_ylabel('Return Value (¬∞C)', fontsize=11, fontweight='bold')\nax1.set_title('Temperature: Return Period Analysis\\n(Annual Maxima Method)', \n              fontsize=12, fontweight='bold')\nax1.grid(True, alpha=0.3)\nax1.set_xscale('log')\n\n# Precipitation return periods\nax2 = axes[1]\nax2.plot(return_periods_precip['return_period_years'], \n        return_periods_precip['return_value'], \n        marker='o', linewidth=2, markersize=8, color='#3498db')\nax2.set_xlabel('Return Period (years)', fontsize=11, fontweight='bold')\nax2.set_ylabel('Return Value (mm)', fontsize=11, fontweight='bold')\nax2.set_title('Precipitation: Return Period Analysis\\n(Peaks Over Threshold Method)', \n              fontsize=12, fontweight='bold')\nax2.grid(True, alpha=0.3)\nax2.set_xscale('log')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"Return Period Analysis Results:\")\nprint(\"\\nTemperature (Annual Maxima):\")\nprint(return_periods_temp.to_string(index=False))\nprint(\"\\nPrecipitation (Peaks Over Threshold):\")\nprint(return_periods_precip.to_string(index=False))\n```\n\n## Correlation Structure: When Variables Move Together\n\nClimate variables don't exist in isolation. Temperature, precipitation, and pressure are coupled through physical processes. The correlation matrix quantifies these relationships, but the interpretation requires care.\n\nA negative correlation between temperature and precipitation might seem counterintuitive, but it reflects the physics: high-pressure systems (clear skies, high temperatures) suppress precipitation, while low-pressure systems (clouds, precipitation) moderate temperatures. The strength of these correlations varies by season and region.\n\nWhy this matters: if variables are correlated, extreme events in one variable are more likely to co-occur with extremes in another. This creates compound risks that simple univariate analysis misses. A heatwave coinciding with low precipitation creates drought stress. A cold snap with high precipitation creates ice storms. The correlation structure tells us which compound events are physically plausible and which are unlikely.\n\n```{python}\n# Compute correlation matrix\ncorr_matrix = analyze_correlations(\n    climate_data,\n    variables=['temperature_c', 'precipitation_mm', 'pressure_hpa']\n)\n\n# Create heatmap\nfig, ax = plt.subplots(figsize=(8, 6))\nif HAS_SEABORN:\n    sns.heatmap(corr_matrix, annot=True, fmt='.3f', cmap='RdBu_r', center=0,\n               square=True, linewidths=1, cbar_kws={\"shrink\": 0.8},\n               vmin=-1, vmax=1, ax=ax)\nelse:\n    im = ax.imshow(corr_matrix.values, cmap='RdBu_r', vmin=-1, vmax=1, aspect='auto')\n    ax.set_xticks(range(len(corr_matrix.columns)))\n    ax.set_yticks(range(len(corr_matrix.index)))\n    ax.set_xticklabels(corr_matrix.columns)\n    ax.set_yticklabels(corr_matrix.index)\n    for i in range(len(corr_matrix.index)):\n        for j in range(len(corr_matrix.columns)):\n            ax.text(j, i, f'{corr_matrix.iloc[i, j]:.3f}', \n                   ha='center', va='center', color='black' if abs(corr_matrix.iloc[i, j]) < 0.5 else 'white')\n    plt.colorbar(im, ax=ax, shrink=0.8)\nax.set_title('Climate Variables Correlation Matrix', \n             fontsize=13, fontweight='bold', pad=15)\nplt.tight_layout()\nplt.show()\n\nprint(\"\\nCorrelation Matrix:\")\nprint(corr_matrix)\n```\n\n## Event Typology: Clustering Extreme Events\n\nNot all extreme events are the same. Hierarchical clustering groups events by their multi-variable signatures, revealing distinct \"types\" of extremes. One cluster might represent \"dry heatwaves\" (high temperature, low precipitation, high pressure), while another represents \"humid heatwaves\" (high temperature, high precipitation, low pressure).\n\nThis typology matters because different event types have different impacts. A dry heatwave increases wildfire risk and water stress. A humid heatwave increases heat stress on humans (reduced evaporative cooling) and can trigger convective storms. The clustering analysis transforms a collection of individual events into a taxonomy of risk scenarios.\n\nThe cluster characteristics plot shows the mean conditions for each event type. Notice how clusters differ not just in temperature, but in the full multi-variable space. This is the power of multivariate analysis: it captures patterns that univariate methods miss.\n\n```{python}\n# Cluster extreme temperature events\nclimate_data = cluster_extreme_events(\n    climate_data,\n    n_clusters=5,\n    variables=['temperature_c', 'precipitation_mm', 'pressure_hpa']\n)\n\n# Visualize clustered extreme events\nfig, axes = plt.subplots(2, 1, figsize=(14, 10), sharex=True)\n\n# Temperature with cluster colors\nax1 = axes[0]\nscatter = ax1.scatter(climate_data['datetime_utc'], climate_data['temperature_c'],\n                     c=climate_data['extreme_cluster'], cmap='Set1', \n                     s=20, alpha=0.6, edgecolors='black', linewidth=0.5)\nextreme_mask = climate_data['is_extreme']\nax1.scatter(climate_data[extreme_mask]['datetime_utc'],\n           climate_data[extreme_mask]['temperature_c'],\n           c=climate_data[extreme_mask]['extreme_cluster'], cmap='Set1',\n           s=100, alpha=0.9, edgecolors='black', linewidth=1.5, \n           marker='*', zorder=5, label='Extreme Events')\nax1.set_ylabel('Temperature (¬∞C)', fontsize=11, fontweight='bold')\nax1.set_title('Temperature Time Series with Clustered Extreme Events', \n              fontsize=13, fontweight='bold', pad=10)\ncbar = plt.colorbar(scatter, ax=ax1)\ncbar.set_label('Cluster ID', fontsize=10)\nax1.legend(loc='upper left', fontsize=9)\nax1.grid(True, alpha=0.3)\n\n# Cluster characteristics\nax2 = axes[1]\ncluster_stats = climate_data[climate_data['extreme_cluster'] > 0].groupby('extreme_cluster').agg({\n    'temperature_c': 'mean',\n    'precipitation_mm': 'mean',\n    'pressure_hpa': 'mean',\n    'extreme_intensity': 'mean',\n}).reset_index()\n\nx_pos = np.arange(len(cluster_stats))\nwidth = 0.35\nax2.bar(x_pos - width/2, cluster_stats['temperature_c'], width, \n       label='Temperature', color='#e74c3c', alpha=0.7)\nax2_twin = ax2.twinx()\nax2_twin.bar(x_pos + width/2, cluster_stats['precipitation_mm'], width,\n            label='Precipitation', color='#3498db', alpha=0.7)\nax2.set_xlabel('Cluster ID', fontsize=11, fontweight='bold')\nax2.set_ylabel('Temperature (¬∞C)', fontsize=11, fontweight='bold', color='#e74c3c')\nax2_twin.set_ylabel('Precipitation (mm)', fontsize=11, fontweight='bold', color='#3498db')\nax2.set_title('Cluster Characteristics: Mean Values by Cluster', \n              fontsize=13, fontweight='bold', pad=10)\nax2.set_xticks(x_pos)\nax2.set_xticklabels(cluster_stats['extreme_cluster'])\nax2.grid(True, alpha=0.3, axis='y')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"\\nCluster Statistics:\")\nprint(cluster_stats.to_string(index=False))\n```\n\n## Intensity Distribution: The Shape of Extremes\n\nThe distribution of extreme event intensities reveals something important: extremes themselves have structure. They're not uniformly distributed‚Äîthere are \"moderate extremes\" and \"extreme extremes.\" The histogram shows a right-skewed distribution, meaning most extreme events are relatively mild (just above the threshold), while truly catastrophic events are rare.\n\nThe box plots by cluster show that different event types have different intensity distributions. Some clusters have tight distributions (consistent intensity), while others are highly variable. This heterogeneity matters for risk assessment: if you're planning for the \"typical extreme,\" you'll be underprepared for the tail events.\n\nThe median being lower than the mean indicates positive skew‚Äîthe distribution has a long right tail. This is characteristic of extreme value distributions and reflects the physics: there's a lower bound (you can't have negative heat), but no upper bound (temperatures can theoretically get arbitrarily high, though practically limited by energy balance).\n\n```{python}\n# Analyze distribution of extreme event intensities\nextreme_events = climate_data[climate_data['is_extreme']].copy()\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Histogram of extreme intensities\nax1 = axes[0]\nax1.hist(extreme_events['extreme_intensity'], bins=30, color='#e74c3c', \n        alpha=0.7, edgecolor='black', linewidth=1.2)\nax1.axvline(extreme_events['extreme_intensity'].mean(), \n           color='#c0392b', linestyle='--', linewidth=2, \n           label=f\"Mean: {extreme_events['extreme_intensity'].mean():.2f}¬∞C\")\nax1.axvline(extreme_events['extreme_intensity'].median(), \n           color='#8e44ad', linestyle='--', linewidth=2,\n           label=f\"Median: {extreme_events['extreme_intensity'].median():.2f}¬∞C\")\nax1.set_xlabel('Extreme Intensity (¬∞C above threshold)', fontsize=11, fontweight='bold')\nax1.set_ylabel('Frequency', fontsize=11, fontweight='bold')\nax1.set_title('Distribution of Extreme Event Intensities', \n              fontsize=12, fontweight='bold')\nax1.legend(fontsize=9)\nax1.grid(True, alpha=0.3, axis='y')\n\n# Box plot by cluster\nax2 = axes[1]\n# Get unique cluster IDs (excluding 0) and filter out empty clusters\nunique_clusters = sorted([i for i in extreme_events['extreme_cluster'].unique() if i > 0])\ncluster_data = []\ncluster_labels = []\nfor i in unique_clusters:\n    data = extreme_events[extreme_events['extreme_cluster'] == i]['extreme_intensity'].values\n    if len(data) > 0:  # Only include clusters with data\n        cluster_data.append(data)\n        cluster_labels.append(str(i))\n\n# Only plot if we have data\nif len(cluster_data) > 0:\n    bp = ax2.boxplot(cluster_data, labels=cluster_labels,\n                    patch_artist=True, showmeans=True)\n    for patch in bp['boxes']:\n        patch.set_facecolor('#e74c3c')\n        patch.set_alpha(0.7)\nelse:\n    ax2.text(0.5, 0.5, 'No cluster data available', \n            ha='center', va='center', transform=ax2.transAxes)\nax2.set_xlabel('Cluster ID', fontsize=11, fontweight='bold')\nax2.set_ylabel('Extreme Intensity (¬∞C above threshold)', fontsize=11, fontweight='bold')\nax2.set_title('Extreme Intensity Distribution by Cluster', \n              fontsize=12, fontweight='bold')\nax2.grid(True, alpha=0.3, axis='y')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"\\nExtreme Event Intensity Statistics:\")\nprint(extreme_events['extreme_intensity'].describe())\n```\n\n## Synthesis: What the Numbers Tell Us\n\nThe summary statistics aggregate the analysis into digestible metrics, but the real insights come from understanding how these pieces fit together. The return period analysis tells us about rarity. The clustering tells us about diversity. The correlation structure tells us about co-occurrence. Together, they paint a picture of a climate system where extremes are:\n\n1. **Rare but not random**: They follow statistical distributions that can be modeled\n2. **Diverse in type**: Not all extremes are the same‚Äîdifferent event types have different impacts\n3. **Correlated in space and time**: Variables move together, creating compound risks\n4. **Heterogeneous in intensity**: Most extremes are moderate; catastrophic events are exponentially rarer\n\nThis framework is the foundation for climate risk assessment. It transforms raw data into actionable intelligence: understanding not just what happened, but what could happen, how often, and in what combinations.\n\n```{python}\n# Generate comprehensive summary\nprint(\"=\" * 70)\nprint(\"CLIMATE EXTREMES ANALYSIS SUMMARY\")\nprint(\"=\" * 70)\n\nprint(f\"\\nüìä Dataset Overview:\")\nprint(f\"   Period: {climate_data['datetime_utc'].min().date()} to {climate_data['datetime_utc'].max().date()}\")\nprint(f\"   Total days: {len(climate_data):,}\")\nprint(f\"   Variables: Temperature, Precipitation, Pressure\")\n\nprint(f\"\\nüå°Ô∏è  Temperature Extremes:\")\nprint(f\"   Total extreme events: {temp_stats['n_events']}\")\nprint(f\"   Extreme days: {temp_stats['total_days']} ({100*temp_stats['total_days']/len(climate_data):.2f}% of period)\")\nprint(f\"   Mean intensity: {temp_stats['mean_intensity']:.2f}¬∞C above 95th percentile\")\nprint(f\"   Maximum intensity: {temp_stats['max_intensity']:.2f}¬∞C above threshold\")\nprint(f\"   Mean duration: {temp_stats['mean_duration']:.1f} days per event\")\n\nprint(f\"\\nüåßÔ∏è  Precipitation Extremes:\")\nprint(f\"   Total extreme events: {precip_stats['n_events']}\")\nprint(f\"   Extreme days: {precip_stats['total_days']} ({100*precip_stats['total_days']/len(climate_data):.2f}% of period)\")\nprint(f\"   Mean intensity: {precip_stats['mean_intensity']:.2f} mm above 95th percentile\")\nprint(f\"   Maximum intensity: {precip_stats['max_intensity']:.2f} mm above threshold\")\n\nprint(f\"\\nüìà Return Period Analysis:\")\nprint(f\"   100-year return temperature: {return_periods_temp[return_periods_temp['return_period_years']==100]['return_value'].values[0]:.2f}¬∞C\")\nprint(f\"   100-year return precipitation: {return_periods_precip[return_periods_precip['return_period_years']==100]['return_value'].values[0]:.2f} mm\")\n\nprint(f\"\\nüîó Variable Correlations:\")\nprint(f\"   Temperature-Precipitation: {corr_matrix.loc['temperature_c', 'precipitation_mm']:.3f}\")\nprint(f\"   Temperature-Pressure: {corr_matrix.loc['temperature_c', 'pressure_hpa']:.3f}\")\nprint(f\"   Precipitation-Pressure: {corr_matrix.loc['precipitation_mm', 'pressure_hpa']:.3f}\")\n\nprint(f\"\\nüéØ Extreme Event Clusters:\")\nprint(f\"   Number of clusters: {climate_data['extreme_cluster'].max()}\")\nfor cluster_id in sorted(cluster_stats['extreme_cluster']):\n    cluster_data = climate_data[climate_data['extreme_cluster'] == cluster_id]\n    print(f\"   Cluster {cluster_id}: {len(cluster_data)} events, \"\n          f\"mean temp {cluster_stats[cluster_stats['extreme_cluster']==cluster_id]['temperature_c'].values[0]:.1f}¬∞C\")\n\nprint(\"\\n\" + \"=\" * 70)\n```\n\n---\n\n## Note\n\nThis analysis uses synthetic climate data for demonstration. In production, this framework can be applied to real ERA5 reanalysis data or observational climate datasets. The methods shown here‚Äîextreme value theory, return period analysis, and event clustering‚Äîare standard approaches in climate risk assessment.\n\n","srcMarkdownNoYaml":"\n\n## Overview\n\nExtreme climate events‚Äîheatwaves, cold snaps, extreme precipitation‚Äîare not anomalies to be dismissed as outliers. They are the signal. Understanding their frequency, intensity, and co-occurrence patterns is fundamental to climate risk assessment. This analysis applies extreme value theory and multivariate statistics to extract structure from what appears chaotic.\n\nThe framework demonstrates:\n\n- **Extreme Event Identification** - Multiple methods (percentile, absolute, anomaly)\n- **Return Period Analysis** - Extreme value theory (Block Maxima, Peaks Over Threshold)\n- **Multi-Variable Correlation** - Relationships between climate variables\n- **Event Clustering** - Hierarchical clustering of extreme events\n- **Statistical Analysis** - Comprehensive extreme event statistics\n\n## Building the Foundation: Synthetic Climate Data\n\nBefore we can identify extremes, we need a baseline. Synthetic data generation here serves two purposes: it provides a controlled environment to test methods, and it demonstrates how realistic climate variability can emerge from relatively simple stochastic processes. The data spans 24 years (2000-2023) with daily resolution, capturing temperature, precipitation, and atmospheric pressure‚Äîthree variables that interact in complex ways.\n\nThe synthetic generation incorporates:\n- **Seasonal cycles** (annual temperature variation, precipitation patterns)\n- **Inter-annual variability** (year-to-year fluctuations)\n- **Cross-variable dependencies** (temperature-precipitation relationships)\n- **Autocorrelation** (weather persistence over days)\n\nThis isn't \"fake data\" in the pejorative sense‚Äîit's a generative model that captures the statistical structure of real climate systems. When we later identify extremes, we're finding events that would be rare under this baseline distribution.\n\n### Generate and Load Climate Data\n\n```{python}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\ntry:\n    import seaborn as sns\n    HAS_SEABORN = True\nexcept ImportError:\n    HAS_SEABORN = False\n    print(\"Note: seaborn not available, using matplotlib for heatmap\")\nfrom scipy import stats\n\nfrom src.climate_extremes import (\n    generate_synthetic_climate_data,\n    identify_extremes,\n    compute_return_periods,\n    analyze_correlations,\n    cluster_extreme_events,\n    compute_extreme_statistics,\n)\n\n# Generate synthetic climate data (2000-2023, daily)\nprint(\"Generating synthetic climate data...\")\nclimate_data = generate_synthetic_climate_data(\n    start_date=\"2000-01-01\",\n    end_date=\"2023-12-31\",\n    freq=\"D\",\n    seed=42\n)\n\nprint(f\"\\nData shape: {climate_data.shape}\")\nprint(f\"Date range: {climate_data['datetime_utc'].min()} to {climate_data['datetime_utc'].max()}\")\nprint(\"\\nFirst few rows:\")\nprint(climate_data.head())\nprint(\"\\nSummary statistics:\")\nprint(climate_data[['temperature_c', 'precipitation_mm', 'pressure_hpa']].describe())\n```\n\n## Defining the Extreme: Operational Thresholds\n\nWhat counts as \"extreme\" is not a question with a single answer. It's a modeling choice with real consequences. We use the 95th percentile threshold‚Äîmeaning 5% of days exceed this value‚Äîbut this is arbitrary. A heatwave that's extreme in one region might be normal in another. A 3-day minimum duration filters out single-day spikes, focusing on sustained events that have greater impact.\n\nThe choice of method matters:\n- **Percentile-based**: Relative to the local distribution (adapts to regional climate)\n- **Absolute thresholds**: Fixed values (e.g., 30¬∞C) that ignore local context\n- **Anomaly-based**: Deviations from expected seasonal patterns\n\nHere, we use percentile thresholds because they're scale-invariant and adapt to the data's inherent variability. A 95th percentile heatwave in a temperate region might be 28¬∞C, while in a desert it might be 42¬∞C‚Äîboth are equally \"extreme\" relative to their contexts.\n\n### Identify Extreme Events\n\n```{python}\n# Identify extreme temperature events (95th percentile, minimum 3 consecutive days)\nclimate_data = identify_extremes(\n    climate_data,\n    variable='temperature_c',\n    method='percentile',\n    threshold=95.0,\n    min_duration=3\n)\n\n# Also identify extreme precipitation events\nclimate_data = identify_extremes(\n    climate_data,\n    variable='precipitation_mm',\n    method='percentile',\n    threshold=95.0,\n    min_duration=1\n)\n\n# Compute statistics\ntemp_stats = compute_extreme_statistics(climate_data, 'temperature_c')\nprecip_stats = compute_extreme_statistics(climate_data, 'precipitation_mm')\n\nprint(\"Temperature Extreme Events:\")\nprint(f\"  Number of events: {temp_stats['n_events']}\")\nprint(f\"  Total extreme days: {temp_stats['total_days']}\")\nprint(f\"  Mean intensity: {temp_stats['mean_intensity']:.2f}¬∞C above threshold\")\nprint(f\"  Maximum intensity: {temp_stats['max_intensity']:.2f}¬∞C above threshold\")\nprint(f\"  Mean duration: {temp_stats['mean_duration']:.1f} days\")\n\nprint(\"\\nPrecipitation Extreme Events:\")\nprint(f\"  Number of events: {precip_stats['n_events']}\")\nprint(f\"  Total extreme days: {precip_stats['total_days']}\")\nprint(f\"  Mean intensity: {precip_stats['mean_intensity']:.2f} mm above threshold\")\nprint(f\"  Maximum intensity: {precip_stats['max_intensity']:.2f} mm above threshold\")\n```\n\n## Temporal Patterns: When Extremes Occur\n\nThe timeline visualization reveals something crucial: extreme events are not uniformly distributed. They cluster in time, creating periods of elevated risk. The temperature extremes show clear seasonal patterns‚Äîheatwaves in summer, cold snaps in winter‚Äîbut also reveal inter-annual variability. Some years are quiet; others are punctuated by multiple extreme events.\n\nThis temporal clustering has implications for risk assessment. If extremes were independent random events, we could model them with simple Poisson processes. But they're not. They exhibit persistence (heatwaves last multiple days) and clustering (extreme years contain multiple extreme events). This means risk is not constant‚Äîit's time-varying and state-dependent.\n\nThe visualization also shows the relationship between variables. Notice how extreme precipitation events sometimes coincide with temperature extremes (convective storms during heatwaves), and sometimes don't (frontal systems during cooler periods). This co-occurrence‚Äîor lack thereof‚Äîmatters for compound risk assessment.\n\n```{python}\n# Create timeline visualization with extreme events highlighted\nfig, axes = plt.subplots(3, 1, figsize=(14, 10), sharex=True)\n\n# Temperature with extreme events\nax1 = axes[0]\nax1.plot(climate_data['datetime_utc'], climate_data['temperature_c'], \n         color='#2c3e50', alpha=0.6, linewidth=0.8, label='Temperature')\nax1.scatter(climate_data[climate_data['is_extreme']]['datetime_utc'],\n           climate_data[climate_data['is_extreme']]['temperature_c'],\n           c='#e74c3c', s=30, alpha=0.7, label='Extreme Events', zorder=5)\nax1.axhline(y=np.percentile(climate_data['temperature_c'], 95), \n           color='#c0392b', linestyle='--', alpha=0.7, label='95th Percentile')\nax1.set_ylabel('Temperature (¬∞C)', fontsize=11, fontweight='bold')\nax1.set_title('Temperature Time Series with Extreme Events Highlighted', \n              fontsize=13, fontweight='bold', pad=10)\nax1.legend(loc='upper left', fontsize=9)\nax1.grid(True, alpha=0.3)\n\n# Precipitation with extreme events\nax2 = axes[1]\nax2.plot(climate_data['datetime_utc'], climate_data['precipitation_mm'], \n         color='#3498db', alpha=0.6, linewidth=0.8, label='Precipitation')\nprecip_extremes = climate_data[climate_data['precipitation_mm'] >= \n                               np.percentile(climate_data['precipitation_mm'], 95)]\nax2.scatter(precip_extremes['datetime_utc'], precip_extremes['precipitation_mm'],\n           c='#2980b9', s=30, alpha=0.7, label='Extreme Events', zorder=5)\nax2.axhline(y=np.percentile(climate_data['precipitation_mm'], 95), \n           color='#21618c', linestyle='--', alpha=0.7, label='95th Percentile')\nax2.set_ylabel('Precipitation (mm)', fontsize=11, fontweight='bold')\nax2.set_title('Precipitation Time Series with Extreme Events Highlighted', \n              fontsize=13, fontweight='bold', pad=10)\nax2.legend(loc='upper left', fontsize=9)\nax2.grid(True, alpha=0.3)\n\n# Pressure\nax3 = axes[2]\nax3.plot(climate_data['datetime_utc'], climate_data['pressure_hpa'], \n         color='#7f8c8d', alpha=0.6, linewidth=0.8)\nax3.set_ylabel('Pressure (hPa)', fontsize=11, fontweight='bold')\nax3.set_xlabel('Date', fontsize=11, fontweight='bold')\nax3.set_title('Atmospheric Pressure Time Series', \n              fontsize=13, fontweight='bold', pad=10)\nax3.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n```\n\n## Return Periods: Quantifying Rarity\n\nReturn period analysis answers a deceptively simple question: \"How often should we expect an event of this magnitude?\" A 100-year return period doesn't mean it happens exactly once per century‚Äîit means the annual probability is 1%. Over a 100-year period, there's a 63% chance of experiencing at least one such event (due to the compounding of probabilities).\n\nThe two methods shown here capture different aspects of extremes:\n- **Block Maxima (Annual Maxima)**: Takes the maximum value each year, fits a Generalized Extreme Value (GEV) distribution. Good for understanding the worst-case scenario in any given year.\n- **Peaks Over Threshold**: Identifies all values above a threshold, fits a Generalized Pareto Distribution (GPD). More data-efficient, captures multiple extremes per year.\n\nThe log-scale x-axis is intentional. Return periods follow a power-law relationship‚Äîdoubling the return period doesn't double the intensity. The curve flattens, meaning truly catastrophic events (1000-year return periods) are only marginally more intense than 100-year events, but exponentially rarer.\n\nThis analysis is the foundation of engineering design standards (dams, bridges, flood defenses) and insurance pricing. The \"100-year flood\" isn't a prediction‚Äîit's a risk metric.\n\n```{python}\n# Compute return periods for temperature extremes\nreturn_periods_temp = compute_return_periods(\n    climate_data,\n    variable='temperature_c',\n    method='block_maxima',\n    block_size='1Y'\n)\n\nreturn_periods_precip = compute_return_periods(\n    climate_data,\n    variable='precipitation_mm',\n    method='peaks_over_threshold',\n)\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Temperature return periods\nax1 = axes[0]\nax1.plot(return_periods_temp['return_period_years'], \n        return_periods_temp['return_value'], \n        marker='o', linewidth=2, markersize=8, color='#e74c3c')\nax1.set_xlabel('Return Period (years)', fontsize=11, fontweight='bold')\nax1.set_ylabel('Return Value (¬∞C)', fontsize=11, fontweight='bold')\nax1.set_title('Temperature: Return Period Analysis\\n(Annual Maxima Method)', \n              fontsize=12, fontweight='bold')\nax1.grid(True, alpha=0.3)\nax1.set_xscale('log')\n\n# Precipitation return periods\nax2 = axes[1]\nax2.plot(return_periods_precip['return_period_years'], \n        return_periods_precip['return_value'], \n        marker='o', linewidth=2, markersize=8, color='#3498db')\nax2.set_xlabel('Return Period (years)', fontsize=11, fontweight='bold')\nax2.set_ylabel('Return Value (mm)', fontsize=11, fontweight='bold')\nax2.set_title('Precipitation: Return Period Analysis\\n(Peaks Over Threshold Method)', \n              fontsize=12, fontweight='bold')\nax2.grid(True, alpha=0.3)\nax2.set_xscale('log')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"Return Period Analysis Results:\")\nprint(\"\\nTemperature (Annual Maxima):\")\nprint(return_periods_temp.to_string(index=False))\nprint(\"\\nPrecipitation (Peaks Over Threshold):\")\nprint(return_periods_precip.to_string(index=False))\n```\n\n## Correlation Structure: When Variables Move Together\n\nClimate variables don't exist in isolation. Temperature, precipitation, and pressure are coupled through physical processes. The correlation matrix quantifies these relationships, but the interpretation requires care.\n\nA negative correlation between temperature and precipitation might seem counterintuitive, but it reflects the physics: high-pressure systems (clear skies, high temperatures) suppress precipitation, while low-pressure systems (clouds, precipitation) moderate temperatures. The strength of these correlations varies by season and region.\n\nWhy this matters: if variables are correlated, extreme events in one variable are more likely to co-occur with extremes in another. This creates compound risks that simple univariate analysis misses. A heatwave coinciding with low precipitation creates drought stress. A cold snap with high precipitation creates ice storms. The correlation structure tells us which compound events are physically plausible and which are unlikely.\n\n```{python}\n# Compute correlation matrix\ncorr_matrix = analyze_correlations(\n    climate_data,\n    variables=['temperature_c', 'precipitation_mm', 'pressure_hpa']\n)\n\n# Create heatmap\nfig, ax = plt.subplots(figsize=(8, 6))\nif HAS_SEABORN:\n    sns.heatmap(corr_matrix, annot=True, fmt='.3f', cmap='RdBu_r', center=0,\n               square=True, linewidths=1, cbar_kws={\"shrink\": 0.8},\n               vmin=-1, vmax=1, ax=ax)\nelse:\n    im = ax.imshow(corr_matrix.values, cmap='RdBu_r', vmin=-1, vmax=1, aspect='auto')\n    ax.set_xticks(range(len(corr_matrix.columns)))\n    ax.set_yticks(range(len(corr_matrix.index)))\n    ax.set_xticklabels(corr_matrix.columns)\n    ax.set_yticklabels(corr_matrix.index)\n    for i in range(len(corr_matrix.index)):\n        for j in range(len(corr_matrix.columns)):\n            ax.text(j, i, f'{corr_matrix.iloc[i, j]:.3f}', \n                   ha='center', va='center', color='black' if abs(corr_matrix.iloc[i, j]) < 0.5 else 'white')\n    plt.colorbar(im, ax=ax, shrink=0.8)\nax.set_title('Climate Variables Correlation Matrix', \n             fontsize=13, fontweight='bold', pad=15)\nplt.tight_layout()\nplt.show()\n\nprint(\"\\nCorrelation Matrix:\")\nprint(corr_matrix)\n```\n\n## Event Typology: Clustering Extreme Events\n\nNot all extreme events are the same. Hierarchical clustering groups events by their multi-variable signatures, revealing distinct \"types\" of extremes. One cluster might represent \"dry heatwaves\" (high temperature, low precipitation, high pressure), while another represents \"humid heatwaves\" (high temperature, high precipitation, low pressure).\n\nThis typology matters because different event types have different impacts. A dry heatwave increases wildfire risk and water stress. A humid heatwave increases heat stress on humans (reduced evaporative cooling) and can trigger convective storms. The clustering analysis transforms a collection of individual events into a taxonomy of risk scenarios.\n\nThe cluster characteristics plot shows the mean conditions for each event type. Notice how clusters differ not just in temperature, but in the full multi-variable space. This is the power of multivariate analysis: it captures patterns that univariate methods miss.\n\n```{python}\n# Cluster extreme temperature events\nclimate_data = cluster_extreme_events(\n    climate_data,\n    n_clusters=5,\n    variables=['temperature_c', 'precipitation_mm', 'pressure_hpa']\n)\n\n# Visualize clustered extreme events\nfig, axes = plt.subplots(2, 1, figsize=(14, 10), sharex=True)\n\n# Temperature with cluster colors\nax1 = axes[0]\nscatter = ax1.scatter(climate_data['datetime_utc'], climate_data['temperature_c'],\n                     c=climate_data['extreme_cluster'], cmap='Set1', \n                     s=20, alpha=0.6, edgecolors='black', linewidth=0.5)\nextreme_mask = climate_data['is_extreme']\nax1.scatter(climate_data[extreme_mask]['datetime_utc'],\n           climate_data[extreme_mask]['temperature_c'],\n           c=climate_data[extreme_mask]['extreme_cluster'], cmap='Set1',\n           s=100, alpha=0.9, edgecolors='black', linewidth=1.5, \n           marker='*', zorder=5, label='Extreme Events')\nax1.set_ylabel('Temperature (¬∞C)', fontsize=11, fontweight='bold')\nax1.set_title('Temperature Time Series with Clustered Extreme Events', \n              fontsize=13, fontweight='bold', pad=10)\ncbar = plt.colorbar(scatter, ax=ax1)\ncbar.set_label('Cluster ID', fontsize=10)\nax1.legend(loc='upper left', fontsize=9)\nax1.grid(True, alpha=0.3)\n\n# Cluster characteristics\nax2 = axes[1]\ncluster_stats = climate_data[climate_data['extreme_cluster'] > 0].groupby('extreme_cluster').agg({\n    'temperature_c': 'mean',\n    'precipitation_mm': 'mean',\n    'pressure_hpa': 'mean',\n    'extreme_intensity': 'mean',\n}).reset_index()\n\nx_pos = np.arange(len(cluster_stats))\nwidth = 0.35\nax2.bar(x_pos - width/2, cluster_stats['temperature_c'], width, \n       label='Temperature', color='#e74c3c', alpha=0.7)\nax2_twin = ax2.twinx()\nax2_twin.bar(x_pos + width/2, cluster_stats['precipitation_mm'], width,\n            label='Precipitation', color='#3498db', alpha=0.7)\nax2.set_xlabel('Cluster ID', fontsize=11, fontweight='bold')\nax2.set_ylabel('Temperature (¬∞C)', fontsize=11, fontweight='bold', color='#e74c3c')\nax2_twin.set_ylabel('Precipitation (mm)', fontsize=11, fontweight='bold', color='#3498db')\nax2.set_title('Cluster Characteristics: Mean Values by Cluster', \n              fontsize=13, fontweight='bold', pad=10)\nax2.set_xticks(x_pos)\nax2.set_xticklabels(cluster_stats['extreme_cluster'])\nax2.grid(True, alpha=0.3, axis='y')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"\\nCluster Statistics:\")\nprint(cluster_stats.to_string(index=False))\n```\n\n## Intensity Distribution: The Shape of Extremes\n\nThe distribution of extreme event intensities reveals something important: extremes themselves have structure. They're not uniformly distributed‚Äîthere are \"moderate extremes\" and \"extreme extremes.\" The histogram shows a right-skewed distribution, meaning most extreme events are relatively mild (just above the threshold), while truly catastrophic events are rare.\n\nThe box plots by cluster show that different event types have different intensity distributions. Some clusters have tight distributions (consistent intensity), while others are highly variable. This heterogeneity matters for risk assessment: if you're planning for the \"typical extreme,\" you'll be underprepared for the tail events.\n\nThe median being lower than the mean indicates positive skew‚Äîthe distribution has a long right tail. This is characteristic of extreme value distributions and reflects the physics: there's a lower bound (you can't have negative heat), but no upper bound (temperatures can theoretically get arbitrarily high, though practically limited by energy balance).\n\n```{python}\n# Analyze distribution of extreme event intensities\nextreme_events = climate_data[climate_data['is_extreme']].copy()\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Histogram of extreme intensities\nax1 = axes[0]\nax1.hist(extreme_events['extreme_intensity'], bins=30, color='#e74c3c', \n        alpha=0.7, edgecolor='black', linewidth=1.2)\nax1.axvline(extreme_events['extreme_intensity'].mean(), \n           color='#c0392b', linestyle='--', linewidth=2, \n           label=f\"Mean: {extreme_events['extreme_intensity'].mean():.2f}¬∞C\")\nax1.axvline(extreme_events['extreme_intensity'].median(), \n           color='#8e44ad', linestyle='--', linewidth=2,\n           label=f\"Median: {extreme_events['extreme_intensity'].median():.2f}¬∞C\")\nax1.set_xlabel('Extreme Intensity (¬∞C above threshold)', fontsize=11, fontweight='bold')\nax1.set_ylabel('Frequency', fontsize=11, fontweight='bold')\nax1.set_title('Distribution of Extreme Event Intensities', \n              fontsize=12, fontweight='bold')\nax1.legend(fontsize=9)\nax1.grid(True, alpha=0.3, axis='y')\n\n# Box plot by cluster\nax2 = axes[1]\n# Get unique cluster IDs (excluding 0) and filter out empty clusters\nunique_clusters = sorted([i for i in extreme_events['extreme_cluster'].unique() if i > 0])\ncluster_data = []\ncluster_labels = []\nfor i in unique_clusters:\n    data = extreme_events[extreme_events['extreme_cluster'] == i]['extreme_intensity'].values\n    if len(data) > 0:  # Only include clusters with data\n        cluster_data.append(data)\n        cluster_labels.append(str(i))\n\n# Only plot if we have data\nif len(cluster_data) > 0:\n    bp = ax2.boxplot(cluster_data, labels=cluster_labels,\n                    patch_artist=True, showmeans=True)\n    for patch in bp['boxes']:\n        patch.set_facecolor('#e74c3c')\n        patch.set_alpha(0.7)\nelse:\n    ax2.text(0.5, 0.5, 'No cluster data available', \n            ha='center', va='center', transform=ax2.transAxes)\nax2.set_xlabel('Cluster ID', fontsize=11, fontweight='bold')\nax2.set_ylabel('Extreme Intensity (¬∞C above threshold)', fontsize=11, fontweight='bold')\nax2.set_title('Extreme Intensity Distribution by Cluster', \n              fontsize=12, fontweight='bold')\nax2.grid(True, alpha=0.3, axis='y')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"\\nExtreme Event Intensity Statistics:\")\nprint(extreme_events['extreme_intensity'].describe())\n```\n\n## Synthesis: What the Numbers Tell Us\n\nThe summary statistics aggregate the analysis into digestible metrics, but the real insights come from understanding how these pieces fit together. The return period analysis tells us about rarity. The clustering tells us about diversity. The correlation structure tells us about co-occurrence. Together, they paint a picture of a climate system where extremes are:\n\n1. **Rare but not random**: They follow statistical distributions that can be modeled\n2. **Diverse in type**: Not all extremes are the same‚Äîdifferent event types have different impacts\n3. **Correlated in space and time**: Variables move together, creating compound risks\n4. **Heterogeneous in intensity**: Most extremes are moderate; catastrophic events are exponentially rarer\n\nThis framework is the foundation for climate risk assessment. It transforms raw data into actionable intelligence: understanding not just what happened, but what could happen, how often, and in what combinations.\n\n```{python}\n# Generate comprehensive summary\nprint(\"=\" * 70)\nprint(\"CLIMATE EXTREMES ANALYSIS SUMMARY\")\nprint(\"=\" * 70)\n\nprint(f\"\\nüìä Dataset Overview:\")\nprint(f\"   Period: {climate_data['datetime_utc'].min().date()} to {climate_data['datetime_utc'].max().date()}\")\nprint(f\"   Total days: {len(climate_data):,}\")\nprint(f\"   Variables: Temperature, Precipitation, Pressure\")\n\nprint(f\"\\nüå°Ô∏è  Temperature Extremes:\")\nprint(f\"   Total extreme events: {temp_stats['n_events']}\")\nprint(f\"   Extreme days: {temp_stats['total_days']} ({100*temp_stats['total_days']/len(climate_data):.2f}% of period)\")\nprint(f\"   Mean intensity: {temp_stats['mean_intensity']:.2f}¬∞C above 95th percentile\")\nprint(f\"   Maximum intensity: {temp_stats['max_intensity']:.2f}¬∞C above threshold\")\nprint(f\"   Mean duration: {temp_stats['mean_duration']:.1f} days per event\")\n\nprint(f\"\\nüåßÔ∏è  Precipitation Extremes:\")\nprint(f\"   Total extreme events: {precip_stats['n_events']}\")\nprint(f\"   Extreme days: {precip_stats['total_days']} ({100*precip_stats['total_days']/len(climate_data):.2f}% of period)\")\nprint(f\"   Mean intensity: {precip_stats['mean_intensity']:.2f} mm above 95th percentile\")\nprint(f\"   Maximum intensity: {precip_stats['max_intensity']:.2f} mm above threshold\")\n\nprint(f\"\\nüìà Return Period Analysis:\")\nprint(f\"   100-year return temperature: {return_periods_temp[return_periods_temp['return_period_years']==100]['return_value'].values[0]:.2f}¬∞C\")\nprint(f\"   100-year return precipitation: {return_periods_precip[return_periods_precip['return_period_years']==100]['return_value'].values[0]:.2f} mm\")\n\nprint(f\"\\nüîó Variable Correlations:\")\nprint(f\"   Temperature-Precipitation: {corr_matrix.loc['temperature_c', 'precipitation_mm']:.3f}\")\nprint(f\"   Temperature-Pressure: {corr_matrix.loc['temperature_c', 'pressure_hpa']:.3f}\")\nprint(f\"   Precipitation-Pressure: {corr_matrix.loc['precipitation_mm', 'pressure_hpa']:.3f}\")\n\nprint(f\"\\nüéØ Extreme Event Clusters:\")\nprint(f\"   Number of clusters: {climate_data['extreme_cluster'].max()}\")\nfor cluster_id in sorted(cluster_stats['extreme_cluster']):\n    cluster_data = climate_data[climate_data['extreme_cluster'] == cluster_id]\n    print(f\"   Cluster {cluster_id}: {len(cluster_data)} events, \"\n          f\"mean temp {cluster_stats[cluster_stats['extreme_cluster']==cluster_id]['temperature_c'].values[0]:.1f}¬∞C\")\n\nprint(\"\\n\" + \"=\" * 70)\n```\n\n---\n\n## Note\n\nThis analysis uses synthetic climate data for demonstration. In production, this framework can be applied to real ERA5 reanalysis data or observational climate datasets. The methods shown here‚Äîextreme value theory, return period analysis, and event clustering‚Äîare standard approaches in climate risk assessment.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":true,"eval":true,"cache":false,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":{"text":"<!-- IBM Plex Sans Font -->\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500&display=swap\" rel=\"stylesheet\">\n\n<!-- IBM Plex Mono Font for code blocks -->\n<link href=\"https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;1,400&display=swap\" rel=\"stylesheet\">\n\n<!-- Plausible analytics -->\n<script defer data-domain=\"recurrentanalytics.com\" src=\"https://plausible.io/js/script.js\"></script>\n\n<!-- D3.js for network graph -->\n<script src=\"https://d3js.org/d3.v7.min.js\"></script>\n\n<!-- Hero drift effect -->\n<style>\n  .rac-hero {\n    position: relative; padding: 5rem 0 4rem; text-align:center;\n    overflow: hidden;\n  }\n  .rac-hero h1 { font-weight: 800; letter-spacing: .5px; }\n  .rac-hero .drift {\n    position: absolute; left: -10%; right:-10%; bottom: -40px; height: 120px;\n    background: radial-gradient(100% 60% at 50% 40%, var(--bs-secondary-bg) 0%, transparent 70%);\n    animation: slowfloat 14s ease-in-out infinite alternate;\n    opacity:.7; filter: blur(10px);\n  }\n  @keyframes slowfloat { from { transform: translateY(0px);} to {transform: translateY(16px);} }\n</style>\n\n<!-- Reading progress bar, keyboard shortcuts -->\n<script>\ndocument.addEventListener('DOMContentLoaded', function() {\n  // Hide page title and reading time on index page\n  const path = window.location.pathname;\n  const isHomePage = path === '/' || path === '/index.html' || path.endsWith('/index.html');\n  \n  if (isHomePage) {\n    document.body.classList.add('index-page');\n    // Hide page title block\n    const titleBlock = document.querySelector('.quarto-title-block');\n    if (titleBlock) {\n      titleBlock.style.display = 'none';\n    }\n    // Remove any reading time that might have been added\n    const readingTime = document.querySelector('.reading-time');\n    if (readingTime) {\n      readingTime.remove();\n    }\n  }\n  \n  // Hide title block on section index pages (projects, notes, reading, tipping-points)\n  // These pages have empty titles in YAML and use headings in content instead\n  const isSectionIndex = path.match(/\\/(projects|notes|reading|tipping-points)\\/?$/);\n  if (isSectionIndex) {\n    const titleBlock = document.querySelector('.quarto-title-block');\n    if (titleBlock) {\n      titleBlock.style.display = 'none';\n    }\n    // Also remove reading time on section pages\n    const readingTime = document.querySelector('.reading-time');\n    if (readingTime) {\n      readingTime.remove();\n    }\n  }\n  \n  // Breadcrumb navigation\n  function createBreadcrumbs() {\n    const path = window.location.pathname;\n    if (path === '/' || path === '/index.html') return;\n    \n    const pathParts = path.split('/').filter(p => p && p !== 'index.html');\n    const breadcrumbContainer = document.createElement('nav');\n    breadcrumbContainer.className = 'breadcrumb-nav';\n    breadcrumbContainer.setAttribute('aria-label', 'Breadcrumb');\n    \n    let breadcrumbHTML = '<ol class=\"breadcrumb-list\">';\n    breadcrumbHTML += '<li class=\"breadcrumb-item\"><a href=\"/\">Home</a></li>';\n    \n    let currentPath = '';\n    pathParts.forEach((part, index) => {\n      const isLast = index === pathParts.length - 1;\n      \n      // Special handling for \"models\" - link to projects page instead\n      if (part === 'models' && !isLast) {\n        breadcrumbHTML += '<li class=\"breadcrumb-item\"><a href=\"/projects/\">Projects</a></li>';\n        return; // Skip adding to currentPath\n      }\n      \n      // Skip \"models\" in breadcrumb if it's not the last part\n      if (part === 'models') {\n        return;\n      }\n      \n      currentPath += '/' + part;\n      const label = part.replace(/\\.html$/, '').replace(/-/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n      \n      if (isLast) {\n        breadcrumbHTML += `<li class=\"breadcrumb-item active\" aria-current=\"page\">${label}</li>`;\n      } else {\n        breadcrumbHTML += `<li class=\"breadcrumb-item\"><a href=\"${currentPath}/\">${label}</a></li>`;\n      }\n    });\n    \n    breadcrumbHTML += '</ol>';\n    breadcrumbContainer.innerHTML = breadcrumbHTML;\n    \n    const contentArea = document.querySelector('#quarto-document-content, .content, main, article');\n    if (contentArea) {\n      contentArea.insertBefore(breadcrumbContainer, contentArea.firstChild);\n    }\n  }\n  \n  createBreadcrumbs();\n  \n  // Reading progress bar\n  const progressBar = document.createElement('div');\n  progressBar.className = 'reading-progress';\n  document.body.appendChild(progressBar);\n  \n  window.addEventListener('scroll', function() {\n    const scrollTop = window.scrollY;\n    const docHeight = document.documentElement.scrollHeight - window.innerHeight;\n    const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;\n    progressBar.style.width = progress + '%';\n  });\n\n  // Focus mode for distraction-free reading\n  let focusMode = false;\n  function toggleFocusMode() {\n    focusMode = !focusMode;\n    document.body.classList.toggle('focus-mode', focusMode);\n    \n    // Hide/show elements\n    const elementsToHide = document.querySelectorAll('.navbar, .nav-footer, .sidebar, #TOC, #quarto-margin-sidebar, .quarto-back-to-top-link, .mobile-graph-btn, .sidebar-graph');\n    elementsToHide.forEach(el => {\n      if (el) el.style.display = focusMode ? 'none' : '';\n    });\n    \n    // Update hint\n    const hint = document.querySelector('.keyboard-hint');\n    if (hint) {\n      hint.innerHTML = focusMode \n        ? 'Press f to exit focus mode ¬∑ Escape to close'\n        : '‚åòK palette ¬∑ / search ¬∑ j/k navigate ¬∑ f focus ¬∑ ? hints';\n    }\n  }\n\n  // Keyboard shortcuts\n  const noteLinks = Array.from(document.querySelectorAll('.quarto-listing-default a, .sidebar-item a'));\n  let currentIndex = -1;\n\n  document.addEventListener('keydown', function(e) {\n    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;\n    \n    // f to toggle focus mode\n    if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {\n      e.preventDefault();\n      toggleFocusMode();\n      return;\n    }\n    \n    // / to focus search\n    if (e.key === '/' && !e.ctrlKey && !e.metaKey) {\n      e.preventDefault();\n      const searchInput = document.querySelector('#quarto-search input, .aa-Input');\n      if (searchInput) searchInput.focus();\n    }\n    \n    // j/k to navigate notes (on listing pages)\n    if (noteLinks.length > 0) {\n      if (e.key === 'j') {\n        currentIndex = Math.min(currentIndex + 1, noteLinks.length - 1);\n        noteLinks[currentIndex]?.focus();\n      }\n      if (e.key === 'k') {\n        currentIndex = Math.max(currentIndex - 1, 0);\n        noteLinks[currentIndex]?.focus();\n      }\n    }\n    \n    // ? to show keyboard hints\n    if (e.key === '?') {\n      const hint = document.querySelector('.keyboard-hint');\n      if (hint) hint.classList.toggle('visible');\n    }\n  });\n\n  // Add keyboard hint element\n  const hint = document.createElement('div');\n  hint.className = 'keyboard-hint';\n  hint.innerHTML = '‚åòK palette ¬∑ / search ¬∑ j/k navigate ¬∑ f focus ¬∑ ? hints';\n  document.body.appendChild(hint);\n\n  // Command Palette (Cmd+K / Ctrl+K)\n  const pages = [\n    { title: 'Home', path: '/' },\n    { title: 'About & Contact', path: '/about.html' },\n    { title: 'Notes & Knowledge Base', path: '/notes/' },\n    { title: 'Projects', path: '/projects/' },\n    { title: 'Reading', path: '/reading/' },\n    { title: 'Tipping Points', path: '/tipping-points/' },\n    { title: 'Design Notes', path: '/tipping-points/design-notes/' },\n    { title: 'Hello, Lab', path: '/notes/2025-hello-world.html' },\n    { title: 'Risk Modelling Part 1: Foundations', path: '/notes/risk-series-1.html' },\n    { title: 'Risk Modelling Part 2: Data', path: '/notes/risk-series-2.html' },\n    { title: 'Risk Modelling Part 3: Implementation', path: '/notes/risk-series-3.html' },\n    { title: 'Heatwaves and Day-Ahead Prices', path: '/models/heatwave-prices-de-lu.html' }\n  ];\n\n  const overlay = document.createElement('div');\n  overlay.className = 'cmd-palette-overlay';\n  overlay.innerHTML = `\n    <div class=\"cmd-palette\">\n      <input type=\"text\" class=\"cmd-palette-input\" placeholder=\"Jump to page...\">\n      <div class=\"cmd-palette-results\"></div>\n    </div>\n  `;\n  document.body.appendChild(overlay);\n\n  const input = overlay.querySelector('.cmd-palette-input');\n  const results = overlay.querySelector('.cmd-palette-results');\n  let selectedIndex = 0;\n\n  // Simple fuzzy search function\n  function fuzzyMatch(pattern, text) {\n    pattern = pattern.toLowerCase();\n    text = text.toLowerCase();\n    \n    // Exact match gets highest score\n    if (text.includes(pattern)) return 100;\n    \n    // Check if all pattern characters appear in order\n    let patternIdx = 0;\n    let score = 0;\n    for (let i = 0; i < text.length && patternIdx < pattern.length; i++) {\n      if (text[i] === pattern[patternIdx]) {\n        patternIdx++;\n        score += 10;\n      }\n    }\n    \n    if (patternIdx === pattern.length) {\n      return score;\n    }\n    \n    // Check individual word matches\n    const words = text.split(/\\s+/);\n    let wordMatches = 0;\n    pattern.split(/\\s+/).forEach(pWord => {\n      if (words.some(w => w.startsWith(pWord) || w.includes(pWord))) {\n        wordMatches++;\n      }\n    });\n    \n    return wordMatches * 5;\n  }\n\n  function renderResults(filter = '') {\n    if (!filter.trim()) {\n      const filtered = pages.slice(0, 10);\n    results.innerHTML = filtered.map((p, i) => `\n      <a href=\"${p.path}\" class=\"cmd-palette-item ${i === selectedIndex ? 'selected' : ''}\">\n        <div class=\"cmd-palette-item-title\">${p.title}</div>\n        <div class=\"cmd-palette-item-path\">${p.path}</div>\n      </a>\n    `).join('');\n    return filtered;\n    }\n    \n    // Score and sort by relevance\n    const scored = pages.map(p => ({\n      page: p,\n      score: Math.max(\n        fuzzyMatch(filter, p.title),\n        fuzzyMatch(filter, p.path)\n      )\n    })).filter(item => item.score > 0)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 10);\n    \n    results.innerHTML = scored.map((item, i) => `\n      <a href=\"${item.page.path}\" class=\"cmd-palette-item ${i === selectedIndex ? 'selected' : ''}\">\n        <div class=\"cmd-palette-item-title\">${item.page.title}</div>\n        <div class=\"cmd-palette-item-path\">${item.page.path}</div>\n      </a>\n    `).join('');\n    return scored.map(item => item.page);\n  }\n\n  function openPalette() {\n    overlay.classList.add('active');\n    input.value = '';\n    selectedIndex = 0;\n    renderResults();\n    setTimeout(() => input.focus(), 50);\n  }\n\n  function closePalette() {\n    overlay.classList.remove('active');\n  }\n\n  overlay.addEventListener('click', (e) => {\n    if (e.target === overlay) closePalette();\n  });\n\n  input.addEventListener('input', () => {\n    selectedIndex = 0;\n    renderResults(input.value);\n  });\n\n  input.addEventListener('keydown', (e) => {\n    const items = results.querySelectorAll('.cmd-palette-item');\n    if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      selectedIndex = Math.min(selectedIndex + 1, items.length - 1);\n      renderResults(input.value);\n    } else if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      selectedIndex = Math.max(selectedIndex - 1, 0);\n      renderResults(input.value);\n    } else if (e.key === 'Enter') {\n      e.preventDefault();\n      if (items[selectedIndex]) items[selectedIndex].click();\n    } else if (e.key === 'Escape') {\n      closePalette();\n    }\n  });\n\n  document.addEventListener('keydown', (e) => {\n    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {\n      e.preventDefault();\n      if (overlay.classList.contains('active')) {\n        closePalette();\n      } else {\n        openPalette();\n      }\n    }\n    if (e.key === 'Escape' && overlay.classList.contains('active')) {\n      closePalette();\n    }\n  });\n\n  // Reading time - add to article pages (but not on index/home page, notes index, or about page)\n  // Reuse path from earlier in the scope\n  const isHomePageForReading = path === '/' || path === '/index.html' || path.endsWith('/index.html');\n  const isNotesIndex = path === '/notes/' || path === '/notes/index.html' || path.endsWith('/notes/index.html');\n  const isAboutPage = path === '/about.html' || path.endsWith('/about.html');\n  \n  if (!isHomePageForReading && !isNotesIndex && !isAboutPage) {\n  const articleBody = document.querySelector('.quarto-title-block, #quarto-document-content');\n  const contentArea = document.querySelector('#quarto-document-content, .content, main');\n  if (articleBody && contentArea) {\n    const text = contentArea.innerText || '';\n    const wordCount = text.trim().split(/\\s+/).length;\n    const readingTime = Math.max(1, Math.ceil(wordCount / 200));\n    const timeSpan = document.createElement('span');\n    timeSpan.className = 'reading-time';\n    timeSpan.textContent = readingTime + ' min read';\n    const titleMeta = document.querySelector('.quarto-title-meta, .quarto-title');\n    if (titleMeta) {\n      titleMeta.appendChild(document.createTextNode(' ¬∑ '));\n      titleMeta.appendChild(timeSpan);\n    }\n  }\n  }\n\n\n  // Network Graph visualization\n  console.log('Starting graph navigation setup...');\n  const graphData = {\n    nodes: [\n      { id: 'home', label: 'Home', path: '/', cat: 'nav' },\n      { id: 'about', label: 'About & Contact', path: '/about.html', cat: 'nav' },\n      { id: 'notes', label: 'Notes', path: '/notes/', cat: 'nav' },\n      { id: 'hello', label: 'Hello, Lab', path: '/notes/2025-hello-world.html', cat: 'notes' },\n      { id: 'risk-1', label: 'Risk Part 1', path: '/notes/risk-series-1.html', cat: 'notes' },\n      { id: 'risk-2', label: 'Risk Part 2', path: '/notes/risk-series-2.html', cat: 'notes' },\n      { id: 'risk-3', label: 'Risk Part 3', path: '/notes/risk-series-3.html', cat: 'notes' },\n      { id: 'heatwave', label: 'Heatwave Prices', path: '/models/heatwave-prices-de-lu.html', cat: 'projects' },\n      { id: 'climate-extremes', label: 'Climate Extremes Explorer', path: '/models/climate-extremes-explorer.html', cat: 'projects' },\n      { id: 'projects', label: 'Projects', path: '/projects/', cat: 'nav' },\n      { id: 'tipping-points', label: 'Tipping Points', path: '/tipping-points/', cat: 'nav' },\n      { id: 'design-notes', label: 'Design Notes', path: '/tipping-points/design-notes/', cat: 'tipping-points' },\n      { id: 'playtest-1', label: 'Playtest Session 1', path: '/tipping-points/design-notes/2025-01-15-playtest-session-1.html', cat: 'tipping-points' },\n      { id: 'mechanics-2', label: 'Mechanics Iteration 2', path: '/tipping-points/design-notes/2025-01-10-mechanics-iteration-2.html', cat: 'tipping-points' },\n      { id: 'heatwave-card', label: 'Card Design: Heatwave', path: '/tipping-points/design-notes/2025-01-05-card-design-heatwave.html', cat: 'tipping-points' }\n    ],\n    links: [\n      { source: 'home', target: 'notes' },\n      { source: 'home', target: 'projects' },\n      { source: 'home', target: 'tipping-points' },\n      { source: 'home', target: 'about' },\n      { source: 'tipping-points', target: 'design-notes' },\n      { source: 'design-notes', target: 'playtest-1' },\n      { source: 'design-notes', target: 'mechanics-2' },\n      { source: 'design-notes', target: 'heatwave-card' },\n      { source: 'playtest-1', target: 'mechanics-2' },\n      { source: 'mechanics-2', target: 'playtest-1' },\n      { source: 'heatwave-card', target: 'design-notes' },\n      { source: 'notes', target: 'hello' },\n      { source: 'notes', target: 'risk-1' },\n      { source: 'risk-1', target: 'risk-2' },\n      { source: 'risk-2', target: 'risk-1' },\n      { source: 'risk-2', target: 'risk-3' },\n      { source: 'risk-2', target: 'heatwave' },\n      { source: 'risk-3', target: 'risk-1' },\n      { source: 'risk-3', target: 'risk-2' },\n      { source: 'projects', target: 'heatwave' },\n      { source: 'projects', target: 'climate-extremes' },\n      { source: 'heatwave', target: 'risk-2' },\n      { source: 'climate-extremes', target: 'risk-2' },\n    ]\n  };\n  \n  // Category colors for graph nodes\n  const catColors = {\n    nav: 'var(--bs-secondary)',\n    notes: 'var(--bs-info)',\n    projects: 'var(--bs-success)',\n    'tipping-points': '#9b59b6'  // Purple for game design content\n  };\n\n  // Create sidebar mini-graph widget - always add to body to ensure it's on all pages\n  const sidebarGraph = document.createElement('div');\n  sidebarGraph.className = 'sidebar-graph';\n  sidebarGraph.title = 'Click to expand';\n  sidebarGraph.innerHTML = `\n    <div class=\"sidebar-graph-header\">\n      <span class=\"sidebar-graph-title\">Connections</span>\n      <span class=\"sidebar-graph-expand\">expand</span>\n    </div>\n    <div class=\"sidebar-graph-container\" id=\"mini-graph-container\"></div>\n  `;\n  \n  // Try to add to sidebar first, but always ensure it's in the DOM\n  console.log('Appending sidebar graph to DOM...');\n  const sidebar = document.querySelector('#quarto-margin-sidebar, .sidebar, #TOC');\n  if (sidebar) {\n    console.log('Sidebar found, appending to sidebar');\n    sidebar.appendChild(sidebarGraph);\n  } else {\n    // If no sidebar, add as fixed element to body\n    console.log('No sidebar found, appending to body as fixed element');\n    document.body.appendChild(sidebarGraph);\n    sidebarGraph.style.position = 'fixed';\n    sidebarGraph.style.bottom = '1rem';\n    sidebarGraph.style.right = '1rem';\n    sidebarGraph.style.width = '200px';\n    sidebarGraph.style.zIndex = '100';\n  }\n  console.log('Sidebar graph in DOM:', document.body.contains(sidebarGraph) || (sidebar && sidebar.contains(sidebarGraph)));\n  \n  // Ensure sidebar graph is always accessible even if sidebar is hidden\n  // Add a fallback fixed position version if sidebar doesn't exist\n  if (!sidebar) {\n    sidebarGraph.style.display = 'block';\n    sidebarGraph.style.visibility = 'visible';\n  }\n  \n  // Force visibility\n  sidebarGraph.style.display = 'block';\n  sidebarGraph.style.visibility = 'visible';\n  sidebarGraph.style.opacity = '1';\n  \n  // Ensure sidebarGraph is clickable - attach handler after it's in DOM\n  setTimeout(function() {\n    const graphEl = document.querySelector('.sidebar-graph');\n    if (graphEl && !graphEl.hasAttribute('data-click-handler-attached')) {\n      graphEl.setAttribute('data-click-handler-attached', 'true');\n      graphEl.addEventListener('click', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        if (typeof window.openGraphNavigation === 'function') {\n          window.openGraphNavigation();\n        }\n      });\n    }\n  }, 100);\n\n  // Create modal FIRST - before any D3 checks\n  console.log('Creating graph modal element...');\n  const graphModal = document.createElement('div');\n  graphModal.className = 'graph-modal-overlay';\n  graphModal.innerHTML = `\n    <div class=\"graph-modal\">\n      <div class=\"graph-modal-header\">\n        <span class=\"graph-modal-title\">Note Connections</span>\n        <button class=\"graph-modal-close\">&times;</button>\n      </div>\n      <div class=\"graph-modal-controls\">\n        <input type=\"text\" class=\"graph-search-input\" placeholder=\"Search nodes...\" id=\"graph-search\">\n        <div class=\"graph-category-filters\">\n          <button class=\"graph-filter-btn active\" data-cat=\"all\">All</button>\n          <button class=\"graph-filter-btn\" data-cat=\"nav\">Nav</button>\n          <button class=\"graph-filter-btn\" data-cat=\"notes\">Notes</button>\n          <button class=\"graph-filter-btn\" data-cat=\"projects\">Projects</button>\n          <button class=\"graph-filter-btn\" data-cat=\"tipping-points\">Tipping Points</button>\n        </div>\n        <div class=\"graph-zoom-controls\">\n          <button class=\"graph-zoom-btn\" id=\"zoom-in\" title=\"Zoom in\">+</button>\n          <button class=\"graph-zoom-btn\" id=\"zoom-out\" title=\"Zoom out\">‚àí</button>\n          <button class=\"graph-zoom-btn\" id=\"zoom-reset\" title=\"Reset zoom\">‚åÇ</button>\n        </div>\n      </div>\n      <div class=\"graph-container\" id=\"graph-container\"></div>\n    </div>\n  `;\n  document.body.appendChild(graphModal);\n\n  function getCurrentPageId() {\n    const path = window.location.pathname;\n    const node = graphData.nodes.find(n => path.endsWith(n.path) || path === n.path || \n      (n.path === '/' && (path === '/' || path === '/index.html' || path.endsWith('/index.html'))));\n    return node ? node.id : null;\n  }\n  \n  // Make getCurrentPageId and graphData available globally\n  window.getCurrentPageId = getCurrentPageId;\n  window.graphData = graphData;\n\n  function openGraph() {\n    console.log('openGraph called', { graphModal: !!graphModal, inDOM: graphModal && document.body.contains(graphModal) });\n    \n    // Ensure graph modal exists\n    if (!graphModal) {\n      console.error('Graph modal not found!');\n      return;\n    }\n    \n    if (!document.body.contains(graphModal)) {\n      console.warn('Graph modal not in DOM, appending...');\n      document.body.appendChild(graphModal);\n    }\n    \n    // Ensure modal is visible\n    graphModal.style.display = 'flex';\n    graphModal.style.visibility = 'visible';\n    graphModal.classList.add('active');\n    \n    // Initialize graph if not already done\n    if (typeof initGraph === 'function') {\n    initGraph();\n    } else {\n      console.error('initGraph function not found');\n    }\n    \n    // Focus trap - prevent body scroll when modal is open\n    document.body.style.overflow = 'hidden';\n  }\n\n  function closeGraph() {\n    if (graphModal) {\n    graphModal.classList.remove('active');\n      // Restore body scroll\n      document.body.style.overflow = '';\n    }\n  }\n  \n  // Make openGraph globally available so it can be called from anywhere\n  window.openGraphNavigation = openGraph;\n\n  // Ensure event listeners are attached after elements are created\n  // Use event delegation to handle clicks on sidebar graph\n  if (sidebarGraph && sidebarGraph.parentNode) {\n    sidebarGraph.addEventListener('click', function(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      if (typeof openGraph === 'function') {\n      openGraph();\n      } else if (typeof window.openGraphNavigation === 'function') {\n        window.openGraphNavigation();\n    }\n  });\n  } else {\n    // If sidebarGraph isn't in DOM yet, wait and retry\n    setTimeout(function() {\n      const graph = document.querySelector('.sidebar-graph');\n      if (graph) {\n        graph.addEventListener('click', function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n          if (typeof window.openGraphNavigation === 'function') {\n            window.openGraphNavigation();\n          }\n        });\n      }\n    }, 500);\n  }\n  \n  const closeBtn = graphModal.querySelector('.graph-modal-close');\n  if (closeBtn) {\n    closeBtn.addEventListener('click', function(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      closeGraph();\n    });\n  }\n  \n  graphModal.addEventListener('click', function(e) {\n    if (e.target === graphModal) {\n      closeGraph();\n    }\n  });\n  \n  // Global keyboard shortcut - attach to document, not just inside DOMContentLoaded\n  function handleGraphKeyboard(e) {\n    // Escape to close graph modal\n    if (e.key === 'Escape' && graphModal && graphModal.classList.contains('active')) {\n      closeGraph();\n      return;\n    }\n    // 'g' key to open graph - works everywhere except in input fields\n    if ((e.key === 'g' || e.key === 'G') && \n        e.target.tagName !== 'INPUT' && \n        e.target.tagName !== 'TEXTAREA' && \n        !e.ctrlKey && \n        !e.metaKey && \n        !e.altKey &&\n        !e.shiftKey) {\n      e.preventDefault();\n      e.stopPropagation();\n      openGraph();\n    }\n  }\n  \n  console.log('Attaching keyboard handler...');\n  document.addEventListener('keydown', handleGraphKeyboard);\n  console.log('Keyboard handler attached to document');\n  \n  // Also attach to window for extra reliability\n  window.addEventListener('keydown', handleGraphKeyboard);\n  console.log('Keyboard handler attached to window');\n  \n  // Test: Try calling openGraph directly to verify it works\n  console.log('openGraph function available:', typeof openGraph);\n  console.log('window.openGraphNavigation available:', typeof window.openGraphNavigation);\n\n  // Render mini-graph in sidebar immediately using D3-force\n  function renderMiniGraph() {\n    const container = document.getElementById('mini-graph-container');\n    if (!container || typeof d3 === 'undefined') return;\n    \n    const width = container.clientWidth || 180;\n    const height = container.clientHeight || 150;\n    const currentId = getCurrentPageId();\n\n    const svg = d3.select(container).append('svg')\n      .attr('viewBox', `0 0 ${width} ${height}`);\n\n    const nodes = graphData.nodes.map(d => ({...d}));\n    const links = graphData.links.map(d => ({source: d.source, target: d.target}));\n\n    const connectedNodes = new Set();\n    graphData.links.forEach(l => {\n      if (l.source === currentId || l.target === currentId) {\n        connectedNodes.add(l.source);\n        connectedNodes.add(l.target);\n      }\n    });\n\n    // Find current node and center it\n    const currentNode = nodes.find(n => n.id === currentId);\n    const centerX = width / 2;\n    const centerY = height / 2;\n    \n    if (currentNode) {\n      // Set current node to center\n      currentNode.fx = centerX;\n      currentNode.fy = centerY;\n    }\n\n    // D3 force simulation for mini graph\n    const simulation = d3.forceSimulation(nodes)\n      .force('link', d3.forceLink(links).id(d => d.id).distance(30))\n      .force('charge', d3.forceManyBody().strength(-60))\n      .force('center', d3.forceCenter(centerX, centerY))\n      .force('collision', d3.forceCollide().radius(10))\n      .stop();\n\n    // Run simulation synchronously for static layout\n    for (let i = 0; i < 100; i++) simulation.tick();\n\n    // Clamp positions (except current node which stays fixed)\n    nodes.forEach(n => {\n      if (n.id !== currentId) {\n      n.x = Math.max(15, Math.min(width - 15, n.x));\n      n.y = Math.max(15, Math.min(height - 15, n.y));\n      }\n    });\n    \n    // Release fixed position after simulation\n    if (currentNode) {\n      currentNode.fx = null;\n      currentNode.fy = null;\n    }\n\n    // Draw links\n    svg.selectAll('line')\n      .data(links)\n      .join('line')\n      .attr('x1', d => d.source.x)\n      .attr('y1', d => d.source.y)\n      .attr('x2', d => d.target.x)\n      .attr('y2', d => d.target.y)\n      .attr('class', d => 'graph-link' + (connectedNodes.has(d.source.id) && connectedNodes.has(d.target.id) ? ' connected' : ''));\n\n    // Draw nodes with hover tooltip\n    const nodeGroups = svg.selectAll('g.mini-node')\n      .data(nodes)\n      .join('g')\n      .attr('class', 'mini-node')\n      .attr('transform', d => `translate(${d.x},${d.y})`);\n\n    nodeGroups.append('circle')\n      .attr('r', d => d.id === currentId ? 6 : (connectedNodes.has(d.id) ? 4 : 3))\n      .attr('fill', d => d.id === currentId ? 'var(--bs-primary)' : (catColors[d.cat] || 'var(--bs-secondary)'))\n      .attr('class', d => 'graph-node' + (d.id === currentId ? ' current' : ''));\n\n    // Tooltip on hover\n    const tooltip = d3.select(container).append('div')\n      .attr('class', 'mini-graph-tooltip')\n      .style('opacity', 0);\n\n    nodeGroups\n      .on('mouseenter', (event, d) => {\n        tooltip.text(d.label)\n          .style('left', (d.x + 10) + 'px')\n          .style('top', (d.y - 5) + 'px')\n          .style('opacity', 1);\n      })\n      .on('mouseleave', () => tooltip.style('opacity', 0));\n  }\n  \n  // Render mini graph - ensure it runs\n  function tryRenderMiniGraph() {\n    const container = document.getElementById('mini-graph-container');\n    if (!container) {\n      console.warn('Mini graph container not found');\n      return false;\n    }\n    if (typeof d3 === 'undefined') {\n      console.warn('D3.js not loaded yet');\n      return false;\n    }\n    if (!graphData) {\n      console.warn('Graph data not available');\n      return false;\n    }\n    try {\n  renderMiniGraph();\n      console.log('Mini graph rendered successfully');\n      return true;\n    } catch (error) {\n      console.error('Error rendering mini graph:', error);\n      return false;\n    }\n  }\n  \n  // Try immediately\n  if (!tryRenderMiniGraph()) {\n    // Wait for D3 to load\n    let attempts = 0;\n    const checkD3 = setInterval(() => {\n      attempts++;\n      if (tryRenderMiniGraph() || attempts > 50) {\n        clearInterval(checkD3);\n      }\n    }, 100);\n  }\n\n  // Mobile floating graph button - always available as fallback\n  const mobileGraphBtn = document.createElement('button');\n  mobileGraphBtn.className = 'mobile-graph-btn';\n  mobileGraphBtn.innerHTML = '&#x1F578;'; // spider web emoji as graph icon\n  mobileGraphBtn.title = 'View connections (or press g)';\n  mobileGraphBtn.setAttribute('aria-label', 'Open connection graph');\n  mobileGraphBtn.type = 'button'; // Prevent form submission\n  mobileGraphBtn.addEventListener('click', function(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    openGraph();\n  });\n  document.body.appendChild(mobileGraphBtn);\n  \n  // Ensure mobile button is always in DOM and accessible\n  mobileGraphBtn.style.display = 'none'; // Hidden by default, shown via CSS on mobile\n  \n  // Debug: Log that graph navigation is initialized\n  console.log('Graph navigation initialized:', {\n    sidebarGraph: !!sidebarGraph,\n    graphModal: !!graphModal,\n    mobileGraphBtn: !!mobileGraphBtn,\n    openGraph: typeof openGraph,\n    graphData: !!graphData,\n    d3Loaded: typeof d3 !== 'undefined',\n    sidebarGraphElement: document.querySelector('.sidebar-graph'),\n    miniGraphContainer: document.getElementById('mini-graph-container')\n  });\n  \n  // Ensure sidebar graph is visible\n  if (sidebarGraph) {\n    console.log('Sidebar graph element created:', sidebarGraph);\n    sidebarGraph.style.display = 'block';\n    sidebarGraph.style.visibility = 'visible';\n    sidebarGraph.style.opacity = '1';\n  }\n  \n  // Test: Make sure openGraph is callable\n  console.log('Testing openGraph function:', typeof openGraph);\n  if (typeof openGraph === 'function') {\n    console.log('openGraph is a function - good!');\n  } else {\n    console.error('openGraph is not a function!', openGraph);\n  }\n  \n  // Test: Make sure keyboard handler is attached\n  console.log('Keyboard handler attached:', typeof handleGraphKeyboard);\n  \n  // Test: Try to manually trigger openGraph after a short delay to verify it works\n  setTimeout(() => {\n    console.log('Testing graph system after 1 second...');\n    const testModal = document.querySelector('.graph-modal-overlay');\n    const testSidebar = document.querySelector('.sidebar-graph');\n    const testBtn = document.querySelector('.mobile-graph-btn');\n    console.log('Elements found:', {\n      modal: !!testModal,\n      sidebar: !!testSidebar,\n      button: !!testBtn\n    });\n  }, 1000);\n\n  let graphInitialized = false;\n  let currentGraphState = { nodes: [], links: [], svg: null, simulation: null };\n  let activeCategory = 'all';\n  let searchFilter = '';\n  \n  let zoomBehavior = null;\n  let currentTransform = d3.zoomIdentity;\n  \n  function initGraph() {\n    console.log('initGraph called', { graphInitialized, d3Loaded: typeof d3 !== 'undefined' });\n    if (graphInitialized || typeof d3 === 'undefined') {\n      console.warn('initGraph skipped:', { graphInitialized, d3Loaded: typeof d3 !== 'undefined' });\n      return;\n    }\n    graphInitialized = true;\n    console.log('Rendering full graph...');\n    renderGraph();\n    \n    // Setup search and filters\n    const searchInput = document.getElementById('graph-search');\n    if (searchInput) {\n      searchInput.addEventListener('input', (e) => {\n        searchFilter = e.target.value.toLowerCase();\n        renderGraph();\n      });\n    }\n    \n    const filterBtns = document.querySelectorAll('.graph-filter-btn');\n    filterBtns.forEach(btn => {\n      btn.addEventListener('click', () => {\n        filterBtns.forEach(b => b.classList.remove('active'));\n        btn.classList.add('active');\n        activeCategory = btn.dataset.cat;\n        renderGraph();\n      });\n    });\n    \n    // Setup zoom controls\n    const zoomInBtn = document.getElementById('zoom-in');\n    const zoomOutBtn = document.getElementById('zoom-out');\n    const zoomResetBtn = document.getElementById('zoom-reset');\n    \n    if (zoomInBtn) {\n      zoomInBtn.addEventListener('click', () => {\n    const container = document.getElementById('graph-container');\n        const svg = d3.select(container).select('svg');\n        if (svg && zoomBehavior) {\n          svg.transition().call(zoomBehavior.scaleBy, 1.5);\n        }\n      });\n    }\n    \n    if (zoomOutBtn) {\n      zoomOutBtn.addEventListener('click', () => {\n        const container = document.getElementById('graph-container');\n        const svg = d3.select(container).select('svg');\n        if (svg && zoomBehavior) {\n          svg.transition().call(zoomBehavior.scaleBy, 1 / 1.5);\n        }\n      });\n    }\n    \n    if (zoomResetBtn) {\n      zoomResetBtn.addEventListener('click', () => {\n        const container = document.getElementById('graph-container');\n        const svg = d3.select(container).select('svg');\n        if (svg && zoomBehavior) {\n          svg.transition().call(zoomBehavior.transform, d3.zoomIdentity);\n        }\n      });\n    }\n  }\n  \n  function renderGraph() {\n    const container = document.getElementById('graph-container');\n    if (!container) return;\n    \n    // Clear existing graph\n    d3.select(container).selectAll('*').remove();\n    \n    const width = container.clientWidth;\n    const height = container.clientHeight;\n    const currentId = getCurrentPageId();\n\n    const svg = d3.select(container).append('svg')\n      .attr('width', width)\n      .attr('height', height);\n\n    // Create a group for all graph elements (for zoom/pan)\n    const g = svg.append('g');\n    \n    // Create zoom behavior\n    zoomBehavior = d3.zoom()\n      .scaleExtent([0.3, 3])\n      .on('zoom', function(event) {\n        currentTransform = event.transform;\n        g.attr('transform', event.transform);\n      });\n\n    // Apply zoom to svg\n    svg.call(zoomBehavior);\n\n    // Filter nodes by category and search\n    let filteredNodes = graphData.nodes.map(d => ({\n      ...d,\n      id: String(d.id)  // Ensure all node IDs are strings\n    }));\n    if (activeCategory !== 'all') {\n      filteredNodes = filteredNodes.filter(n => n.cat === activeCategory);\n    }\n    if (searchFilter) {\n      filteredNodes = filteredNodes.filter(n => \n        n.label.toLowerCase().includes(searchFilter) || \n        n.path.toLowerCase().includes(searchFilter)\n      );\n    }\n    \n    const nodeIds = new Set(filteredNodes.map(n => String(n.id)));\n    \n    // Filter links to only include filtered nodes\n    // Create new link objects with string IDs for D3 forceLink\n    const filteredLinks = graphData.links\n      .filter(l => {\n        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;\n        const targetId = typeof l.target === 'object' ? l.target.id : l.target;\n        return nodeIds.has(sourceId) && nodeIds.has(targetId);\n      })\n      .map(l => {\n        // Create new objects with string IDs (don't reference original)\n        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;\n        const targetId = typeof l.target === 'object' ? l.target.id : l.target;\n        return {source: String(sourceId), target: String(targetId)};\n      });\n\n    // Find connected nodes and paths\n    const connectedNodes = new Set();\n    const paths = new Map();\n    \n    graphData.links.forEach(l => {\n      const sourceId = typeof l.source === 'object' ? l.source.id : l.source;\n      const targetId = typeof l.target === 'object' ? l.target.id : l.target;\n      \n      if (sourceId === currentId || targetId === currentId) {\n        connectedNodes.add(sourceId);\n        connectedNodes.add(targetId);\n      }\n      \n      // Build path map for highlighting\n      if (!paths.has(sourceId)) paths.set(sourceId, new Set());\n      paths.get(sourceId).add(targetId);\n      if (!paths.has(targetId)) paths.set(targetId, new Set());\n      paths.get(targetId).add(sourceId);\n    });\n    \n    // Find all nodes in paths from current\n    function findPathNodes(startId, visited = new Set()) {\n      if (visited.has(startId)) return visited;\n      visited.add(startId);\n      const neighbors = paths.get(startId) || new Set();\n      neighbors.forEach(neighbor => {\n        if (nodeIds.has(neighbor)) {\n          findPathNodes(neighbor, visited);\n      }\n    });\n      return visited;\n    }\n    \n    const pathNodes = currentId ? findPathNodes(currentId) : new Set();\n\n    // Find current node and center it\n    const currentNode = filteredNodes.find(n => String(n.id) === String(currentId));\n    const centerX = width / 2;\n    const centerY = height / 2;\n    \n    if (currentNode) {\n      // Set current node to center and fix it there\n      currentNode.fx = centerX;\n      currentNode.fy = centerY;\n    }\n\n    // D3 force simulation for full graph - centered on current node\n    // Create a map for quick node lookup by ID\n    const nodeMap = new Map(filteredNodes.map(n => [String(n.id), n]));\n    \n    // Ensure all links reference valid node IDs (filteredLinks already has string IDs)\n    const validLinks = filteredLinks.filter(l => {\n      const sourceId = String(l.source);\n      const targetId = String(l.target);\n      return nodeMap.has(sourceId) && nodeMap.has(targetId);\n    }).map(l => ({\n      // Create fresh objects to avoid mutation issues\n      source: String(l.source),\n      target: String(l.target)\n    }));\n    \n    const simulation = d3.forceSimulation(filteredNodes)\n      .force('link', d3.forceLink(validLinks).id(d => String(d.id)).distance(80))\n      .force('charge', d3.forceManyBody().strength(-200))\n      .force('center', d3.forceCenter(centerX, centerY))\n      .force('collision', d3.forceCollide().radius(25))\n      .stop();\n\n    // Run simulation synchronously\n    for (let i = 0; i < 150; i++) simulation.tick();\n\n    // Clamp positions (except current node which stays fixed at center)\n    filteredNodes.forEach(n => {\n      if (String(n.id) !== String(currentId)) {\n      n.x = Math.max(50, Math.min(width - 50, n.x));\n      n.y = Math.max(50, Math.min(height - 50, n.y));\n      }\n    });\n    \n    // Keep current node at center (don't release fixed position)\n    // This ensures it stays centered even if simulation continues\n    if (currentNode) {\n      currentNode.fx = centerX;\n      currentNode.fy = centerY;\n    }\n\n    // Draw links with path highlighting (inside the g group for zoom/pan)\n    // After simulation, D3 mutates validLinks: source/target are now node objects\n    g.selectAll('line.graph-link')\n      .data(validLinks)\n      .join('line')\n      .attr('class', 'graph-link')\n      .attr('x1', d => {\n        // After simulation, source/target are node objects with x/y properties\n        if (d.source && typeof d.source === 'object' && typeof d.source.x === 'number') {\n          return d.source.x;\n        }\n        // Fallback: find node by ID if source is still a string\n        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;\n        const sourceNode = filteredNodes.find(n => String(n.id) === String(sourceId));\n        return sourceNode && typeof sourceNode.x === 'number' ? sourceNode.x : 0;\n      })\n      .attr('y1', d => {\n        if (d.source && typeof d.source === 'object' && typeof d.source.y === 'number') {\n          return d.source.y;\n        }\n        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;\n        const sourceNode = filteredNodes.find(n => String(n.id) === String(sourceId));\n        return sourceNode && typeof sourceNode.y === 'number' ? sourceNode.y : 0;\n      })\n      .attr('x2', d => {\n        if (d.target && typeof d.target === 'object' && typeof d.target.x === 'number') {\n          return d.target.x;\n        }\n        const targetId = typeof d.target === 'object' ? d.target.id : d.target;\n        const targetNode = filteredNodes.find(n => String(n.id) === String(targetId));\n        return targetNode && typeof targetNode.x === 'number' ? targetNode.x : 0;\n      })\n      .attr('y2', d => {\n        if (d.target && typeof d.target === 'object' && typeof d.target.y === 'number') {\n          return d.target.y;\n        }\n        const targetId = typeof d.target === 'object' ? d.target.id : d.target;\n        const targetNode = filteredNodes.find(n => String(n.id) === String(targetId));\n        return targetNode && typeof targetNode.y === 'number' ? targetNode.y : 0;\n      })\n      .attr('class', d => {\n        // Get IDs from node objects (after simulation) or fallback to string IDs\n        const sourceId = d.source && typeof d.source === 'object' ? String(d.source.id) : String(d.source);\n        const targetId = d.target && typeof d.target === 'object' ? String(d.target.id) : String(d.target);\n        const bothConnected = connectedNodes.has(sourceId) && connectedNodes.has(targetId);\n        const bothInPath = pathNodes.has(sourceId) && pathNodes.has(targetId);\n        return 'graph-link' + (bothConnected ? ' connected' : '') + (bothInPath ? ' path' : '');\n      });\n\n    // Draw nodes with labels (inside the g group for zoom/pan)\n    const nodeGroups = g.selectAll('g.graph-node')\n      .data(filteredNodes)\n      .join('g')\n      .attr('class', d => {\n        const isCurrent = d.id === currentId;\n        const isConnected = connectedNodes.has(d.id);\n        const isInPath = pathNodes.has(d.id);\n        return 'graph-node' + \n          (isCurrent ? ' current' : '') + \n          (isConnected ? ' connected' : '') +\n          (isInPath ? ' path' : '');\n      })\n      .attr('transform', d => `translate(${d.x},${d.y})`)\n      .style('cursor', 'pointer')\n      .on('click', (event, d) => { window.location.href = d.path; });\n\n    nodeGroups.append('circle')\n      .attr('r', d => {\n        if (d.id === currentId) return 10;\n        if (connectedNodes.has(d.id)) return 8;\n        if (pathNodes.has(d.id)) return 7;\n        return 6;\n      })\n      .attr('fill', d => {\n        if (d.id === currentId) return '#20B2AA';  /* True Teal */\n        if (connectedNodes.has(d.id)) return catColors[d.cat] || 'var(--bs-secondary)';\n        if (pathNodes.has(d.id)) return catColors[d.cat] || 'var(--bs-secondary)';\n        return catColors[d.cat] || 'var(--bs-secondary)';\n      })\n      .attr('opacity', d => {\n        if (d.id === currentId) return 1;\n        if (connectedNodes.has(d.id)) return 1;\n        if (pathNodes.has(d.id)) return 0.8;\n        return 0.5;\n      });\n\n    nodeGroups.append('text')\n      .attr('y', 20)\n      .text(d => d.label);\n    \n    currentGraphState = { nodes: filteredNodes, links: filteredLinks, svg, simulation };\n  }\n});\n</script>\n\n<!-- Image Lightbox/Modal for clickable enlargements -->\n<style>\n/* Lightbox overlay */\n.image-lightbox {\n  display: none;\n  position: fixed;\n  z-index: 10000;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.9);\n  cursor: pointer;\n  opacity: 0;\n  transition: opacity 0.3s ease;\n}\n\n.image-lightbox.active {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  opacity: 1;\n}\n\n.image-lightbox-content {\n  max-width: 95%;\n  max-height: 95%;\n  margin: auto;\n  display: block;\n  object-fit: contain;\n  cursor: default;\n}\n\n.image-lightbox-close {\n  position: absolute;\n  top: 20px;\n  right: 35px;\n  color: #f1f1f1;\n  font-size: 40px;\n  font-weight: bold;\n  cursor: pointer;\n  z-index: 10001;\n  line-height: 1;\n  transition: color 0.2s;\n}\n\n.image-lightbox-close:hover,\n.image-lightbox-close:focus {\n  color: #fff;\n  text-decoration: none;\n}\n\n/* Make figures and images clickable */\n.quarto-figure,\nfigure,\n.cell-output-display img,\n.cell-output-display svg,\n.quarto-plot img,\nimg[src*=\".png\"],\nimg[src*=\".jpg\"],\nimg[src*=\".jpeg\"],\nimg[src*=\".svg\"] {\n  cursor: pointer;\n  transition: opacity 0.2s;\n}\n\n.quarto-figure:hover,\nfigure:hover,\n.cell-output-display img:hover,\n.cell-output-display svg:hover,\n.quarto-plot img:hover,\nimg[src*=\".png\"]:hover,\nimg[src*=\".jpg\"]:hover,\nimg[src*=\".jpeg\"]:hover,\nimg[src*=\".svg\"]:hover {\n  opacity: 0.9;\n}\n\n/* Exclude icons and small images */\n.navbar img,\n.nav-footer img,\nimg[width][width<100],\nimg[height][height<100] {\n  cursor: default;\n}\n</style>\n\n<script>\ndocument.addEventListener('DOMContentLoaded', function() {\n  // Create lightbox element\n  const lightbox = document.createElement('div');\n  lightbox.className = 'image-lightbox';\n  lightbox.innerHTML = '<span class=\"image-lightbox-close\">&times;</span><img class=\"image-lightbox-content\" src=\"\" alt=\"\">';\n  document.body.appendChild(lightbox);\n\n  const lightboxImg = lightbox.querySelector('img');\n  const lightboxClose = lightbox.querySelector('.image-lightbox-close');\n\n  // Function to open lightbox\n  function openLightbox(imgSrc, imgAlt) {\n    lightboxImg.src = imgSrc;\n    lightboxImg.alt = imgAlt || '';\n    lightbox.classList.add('active');\n    document.body.style.overflow = 'hidden';\n  }\n\n  // Function to close lightbox\n  function closeLightbox() {\n    lightbox.classList.remove('active');\n    document.body.style.overflow = '';\n  }\n\n  // Close on X click\n  lightboxClose.addEventListener('click', closeLightbox);\n\n  // Close on overlay click\n  lightbox.addEventListener('click', function(e) {\n    if (e.target === lightbox) {\n      closeLightbox();\n    }\n  });\n\n  // Close on Escape key\n  document.addEventListener('keydown', function(e) {\n    if (e.key === 'Escape' && lightbox.classList.contains('active')) {\n      closeLightbox();\n    }\n  });\n\n  // Make all figures and images clickable\n  const selectors = [\n    '.quarto-figure img',\n    'figure img',\n    '.cell-output-display img',\n    '.cell-output-display svg',\n    '.quarto-plot img',\n    '.quarto-figure svg',\n    'figure svg'\n  ];\n\n  selectors.forEach(selector => {\n    document.querySelectorAll(selector).forEach(img => {\n      // Skip small images (likely icons)\n      if (img.width && img.width < 100) return;\n      if (img.height && img.height < 100) return;\n      \n      // Skip navbar/footer images\n      if (img.closest('.navbar') || img.closest('.nav-footer')) return;\n\n      img.style.cursor = 'pointer';\n      img.addEventListener('click', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const src = this.src || this.getAttribute('data-src') || this.href;\n        if (src) {\n          openLightbox(src, this.alt || '');\n        }\n      });\n    });\n  });\n\n  // Also handle figure containers\n  document.querySelectorAll('.quarto-figure, figure').forEach(figure => {\n    const img = figure.querySelector('img, svg');\n    if (img && !img.closest('.navbar') && !img.closest('.nav-footer')) {\n      figure.style.cursor = 'pointer';\n      figure.addEventListener('click', function(e) {\n        if (e.target.tagName !== 'IMG' && e.target.tagName !== 'SVG') {\n          const img = this.querySelector('img, svg');\n          if (img) {\n            e.preventDefault();\n            e.stopPropagation();\n            const src = img.src || img.getAttribute('data-src') || img.href;\n            if (src) {\n              openLightbox(src, img.alt || '');\n            }\n          }\n        }\n      });\n    }\n  });\n\n  // Back to top button\n  (function() {\n    const backToTopBtn = document.createElement('button');\n    backToTopBtn.className = 'back-to-top-btn';\n    backToTopBtn.innerHTML = '‚Üë';\n    backToTopBtn.setAttribute('aria-label', 'Back to top');\n    backToTopBtn.setAttribute('title', 'Back to top');\n    backToTopBtn.type = 'button';\n    \n    if (document.body) {\n      document.body.appendChild(backToTopBtn);\n    } else {\n      // Wait for body if not ready\n      setTimeout(function() {\n        document.body.appendChild(backToTopBtn);\n      }, 100);\n    }\n\n    function updateBackToTopVisibility() {\n      if (!backToTopBtn.parentNode) return;\n      const scrollY = window.pageYOffset || document.documentElement.scrollTop || window.scrollY || 0;\n      if (scrollY > 300) {\n        backToTopBtn.classList.add('visible');\n      } else {\n        backToTopBtn.classList.remove('visible');\n      }\n    }\n\n    // Use both scroll events for better compatibility\n    window.addEventListener('scroll', updateBackToTopVisibility, { passive: true });\n    document.addEventListener('scroll', updateBackToTopVisibility, { passive: true });\n    updateBackToTopVisibility(); // Check on load\n\n    backToTopBtn.addEventListener('click', function(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      // Try multiple scroll methods for compatibility\n      if (window.scrollTo) {\n        window.scrollTo({\n          top: 0,\n          behavior: 'smooth'\n        });\n      } else if (document.documentElement.scrollTo) {\n        document.documentElement.scrollTo({\n          top: 0,\n          behavior: 'smooth'\n        });\n      } else {\n        // Fallback\n        window.scrollTo(0, 0);\n      }\n    });\n  })();\n\n\n  // Related Notes Section\n  function addRelatedNotes() {\n    // Only on note pages (not index, not projects, etc.)\n    const path = window.location.pathname;\n    const isNotePage = path.startsWith('/notes/') && \n                      !path.endsWith('/notes/') && \n                      !path.endsWith('/notes/index.html') &&\n                      path.includes('.html');\n    \n    if (!isNotePage) return;\n\n    // Get current page categories from meta tags or page data\n    const currentCategories = [];\n    const currentTags = [];\n    \n    // Try to get from meta tags\n    const categoryMeta = document.querySelector('meta[name=\"categories\"], meta[property=\"article:tag\"]');\n    if (categoryMeta) {\n      const cats = categoryMeta.content.split(',').map(c => c.trim());\n      currentCategories.push(...cats);\n    }\n    \n    // Try to get from page data attributes\n    const pageData = document.querySelector('[data-categories]');\n    if (pageData) {\n      const cats = pageData.getAttribute('data-categories').split(',').map(c => c.trim());\n      currentCategories.push(...cats);\n    }\n\n    // Get all notes from search.json or listings\n    fetch('/search.json')\n      .then(response => response.json())\n      .then(data => {\n        // Extract unique note pages\n        const notePages = new Map();\n        data.forEach(item => {\n          if (item.href && item.href.startsWith('/notes/') && \n              !item.href.endsWith('/notes/index.html') &&\n              item.href.includes('.html') &&\n              !item.section) { // Only main pages, not sections\n            if (!notePages.has(item.href) || !notePages.get(item.href).title) {\n              notePages.set(item.href, {\n                href: item.href,\n                title: item.title || 'Untitled',\n                text: item.text || ''\n              });\n            }\n          }\n        });\n\n        // Find related notes (simple: same title words or series)\n        const currentTitle = document.querySelector('h1, .quarto-title h1')?.textContent || '';\n        const currentText = document.body.innerText || '';\n        const currentTitleWords = currentTitle.toLowerCase().split(/\\s+/);\n        \n        const related = Array.from(notePages.values())\n          .filter(note => {\n            // Don't include current page\n            if (note.href === path || note.href === path.replace('.html', '')) return false;\n            \n            // Check for shared words in title\n            const noteTitleWords = note.title.toLowerCase().split(/\\s+/);\n            const sharedWords = currentTitleWords.filter(w => \n              w.length > 3 && noteTitleWords.includes(w)\n            );\n            \n            // Check for series (e.g., \"Part 1\", \"Part 2\")\n            const isSeries = /part\\s+\\d+/i.test(currentTitle) && /part\\s+\\d+/i.test(note.title);\n            \n            return sharedWords.length > 0 || isSeries || \n                   (currentText.includes('risk') && note.text.toLowerCase().includes('risk')) ||\n                   (currentText.includes('climate') && note.text.toLowerCase().includes('climate'));\n          })\n          .slice(0, 5); // Limit to 5 related notes\n\n        if (related.length > 0) {\n          // Create related notes section\n          const relatedSection = document.createElement('div');\n          relatedSection.className = 'related-notes-section';\n          relatedSection.innerHTML = `\n            <h2 class=\"related-notes-heading\">Related Notes</h2>\n            <ul class=\"related-notes-list\">\n              ${related.map(note => `\n                <li>\n                  <a href=\"${note.href}\">${note.title}</a>\n                </li>\n              `).join('')}\n            </ul>\n          `;\n\n          // Insert before footer or at end of content\n          const content = document.querySelector('#quarto-document-content, .content, main, article');\n          if (content) {\n            content.appendChild(relatedSection);\n          }\n        }\n      })\n      .catch(err => console.log('Could not load related notes:', err));\n  }\n\n  // Run after page load\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', addRelatedNotes);\n  } else {\n    addRelatedNotes();\n  }\n});\n</script>\n\n<style>\n/* Related Notes Section */\n.related-notes-section {\n  margin-top: 3rem;\n  padding-top: 2rem;\n  border-top: 1px solid var(--bs-border-color);\n}\n\n.related-notes-heading {\n  font-size: 1.25rem;\n  font-weight: 600;\n  margin-bottom: 1rem;\n  color: var(--bs-body-color);\n}\n\n.related-notes-list {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.related-notes-list li {\n  margin-bottom: 0.75rem;\n  padding-left: 1.5rem;\n  position: relative;\n}\n\n.related-notes-list li::before {\n  content: '‚Üí';\n  position: absolute;\n  left: 0;\n  color: var(--bs-secondary);\n}\n\n.related-notes-list a {\n  color: #1a1a1a !important;  /* Subtle, matches body text */\n  text-decoration: none;\n  transition: color 0.2s;\n}\n\n.related-notes-list a:hover {\n  color: #20B2AA !important;  /* Teal on hover for interactivity */\n  text-decoration: underline;\n}\n</style>\n\n<style>\n/* Back to top button */\n.back-to-top-btn {\n  position: fixed;\n  bottom: 2rem;\n  right: 2rem;\n  width: 48px;\n  height: 48px;\n  border-radius: 50%;\n  background: var(--bs-body-bg);\n  border: 1px solid var(--bs-border-color);\n  color: var(--bs-body-color);\n  font-size: 1.2rem;\n  cursor: pointer;\n  z-index: 999;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n  transition: all 0.3s ease;\n  opacity: 0;\n  visibility: hidden;\n  transform: translateY(20px);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.back-to-top-btn.visible {\n  opacity: 1;\n  visibility: visible;\n  transform: translateY(0);\n}\n\n.back-to-top-btn:hover {\n  background: var(--bs-primary);\n  color: var(--bs-body-bg);\n  border-color: var(--bs-primary);\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n}\n\n.back-to-top-btn:active {\n  transform: translateY(0);\n}\n\n@media (max-width: 768px) {\n  .back-to-top-btn {\n    bottom: 1rem;\n    right: 1rem;\n    width: 44px;\n    height: 44px;\n    font-size: 1.1rem;\n  }\n}\n\n/* Hide in print */\n@media print {\n  .back-to-top-btn {\n    display: none !important;\n  }\n}\n</style>\n\n<style>\n/* Collapsible Code Blocks - Global */\n.code-block-wrapper {\n  margin: 1.5rem 0;\n  border: 1px solid var(--bs-border-color);\n  border-radius: 0.5rem;\n  background: #f8f8f8;\n  overflow: hidden;\n}\n\n.code-block-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.5rem 1rem;\n  background: #f0f0f0;\n  border-bottom: 1px solid var(--bs-border-color);\n  cursor: pointer;\n  user-select: none;\n  transition: background 0.2s ease;\n}\n\n.code-block-header:hover {\n  background: #e8e8e8;\n}\n\n.code-block-title {\n  font-family: \"IBM Plex Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", system-ui, sans-serif;\n  font-size: 0.85rem;\n  font-weight: 500;\n  color: #666;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.code-block-toggle {\n  font-size: 0.75rem;\n  color: #666;\n  transition: transform 0.2s ease;\n  display: inline-block;\n}\n\n.code-block-wrapper.expanded .code-block-toggle {\n  transform: rotate(180deg);\n}\n\n.code-block-content {\n  display: none;\n  overflow: hidden;\n}\n\n.code-block-wrapper.expanded .code-block-content {\n  display: block;\n}\n\n.code-block-wrapper pre,\n.code-block-wrapper code {\n  margin: 0;\n  border-radius: 0;\n}\n\n/* Ensure outputs are always visible - never collapse them */\n.cell-output,\n.cell-output-stdout,\n.cell-output-stderr,\n.cell-output-display,\n.cell-output pre,\n.cell-output code {\n  display: block !important;\n  visibility: visible !important;\n  opacity: 1 !important;\n}\n\n/* Ensure unwrapped code blocks are visible until JavaScript wraps them */\npre.sourceCode:not(.code-block-wrapper pre.sourceCode),\n.cell-code:not(.code-block-wrapper .cell-code) {\n  display: block !important;\n}\n</style>\n\n<script>\n(function() {\n  // Function to wrap code blocks in collapsible structure\n  // ONLY wrap input code blocks, NOT outputs\n  function makeCodeBlocksCollapsible() {\n    try {\n    // Find only INPUT code blocks - exclude outputs\n    // Target pre.sourceCode (standalone code blocks) and .cell-code (input code in cells)\n    // Exclude ones already wrapped and exclude any inside .cell-output\n    const codeBlocks = document.querySelectorAll('pre.sourceCode:not(.code-block-wrapper pre.sourceCode):not(.cell-output pre), .cell-code:not(.code-block-wrapper .cell-code):not(.cell-output .cell-code)');\n    \n    if (codeBlocks.length === 0) return;\n    \n    codeBlocks.forEach(function(block) {\n      // Skip if already wrapped\n      if (block.closest('.code-block-wrapper')) {\n        return;\n      }\n\n      // Skip if inside output container\n      if (block.closest('.cell-output, .cell-output-stdout, .cell-output-stderr, .cell-output-display')) {\n        return;\n      }\n\n      // Skip inline code\n      if (block.tagName === 'CODE' && block.parentElement && block.parentElement.tagName !== 'PRE') {\n        return;\n      }\n\n      // Get language from class or parent\n      let language = 'code';\n      const classList = block.className || '';\n      if (classList.includes('sourceCode')) {\n        const match = classList.match(/sourceCode-(\\w+)/);\n        if (match) language = match[1];\n      } else if (block.querySelector('code')) {\n        const codeEl = block.querySelector('code');\n        if (codeEl && codeEl.className) {\n          const match = codeEl.className.match(/language-(\\w+)|sourceCode-(\\w+)/);\n          if (match) language = match[1] || match[2];\n        }\n      }\n\n      // Create wrapper\n      const wrapper = document.createElement('div');\n      wrapper.className = 'code-block-wrapper';\n\n      // Create header\n      const header = document.createElement('div');\n      header.className = 'code-block-header';\n      header.innerHTML = `\n        <span class=\"code-block-title\">\n          <span class=\"code-block-toggle\">‚ñº</span>\n          <span>${language}</span>\n        </span>\n      `;\n\n      // Create content container\n      const content = document.createElement('div');\n      content.className = 'code-block-content';\n      \n      // Store parent and next sibling BEFORE moving block\n      const parent = block.parentNode;\n      const nextSibling = block.nextSibling;\n      \n      // Move the block into content (don't clone, move it)\n      // This removes block from parent, so we need parent/nextSibling before this\n      content.appendChild(block);\n\n      // Assemble\n      wrapper.appendChild(header);\n      wrapper.appendChild(content);\n      \n      // Insert wrapper where block was\n      // Note: block is now inside content, so we insert wrapper at block's old position\n      if (parent) {\n        // If there's a next sibling, insert before it (block was before nextSibling)\n        // Otherwise append to end\n        if (nextSibling && nextSibling.parentNode === parent) {\n          parent.insertBefore(wrapper, nextSibling);\n        } else {\n          // If nextSibling is null or invalid, append to parent\n          parent.appendChild(wrapper);\n        }\n      }\n\n      // Add click handler\n      header.addEventListener('click', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        wrapper.classList.toggle('expanded');\n      });\n    });\n    } catch (error) {\n      console.error('Error in makeCodeBlocksCollapsible:', error);\n      // Don't break the page if code block wrapping fails\n    }\n  }\n\n  // Run when DOM is ready\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', makeCodeBlocksCollapsible);\n  } else {\n    // DOM already loaded\n    makeCodeBlocksCollapsible();\n  }\n\n  // Also run after delays to catch dynamically loaded content\n  setTimeout(makeCodeBlocksCollapsible, 100);\n  setTimeout(makeCodeBlocksCollapsible, 500);\n  setTimeout(makeCodeBlocksCollapsible, 1000);\n\n  // Use MutationObserver to catch dynamically added code blocks\n  const observer = new MutationObserver(function(mutations) {\n    let shouldRun = false;\n    mutations.forEach(function(mutation) {\n      if (mutation.addedNodes.length > 0) {\n        mutation.addedNodes.forEach(function(node) {\n          if (node.nodeType === 1) { // Element node\n            // Only trigger if it's an input code block, not an output\n            if (node.matches && (\n              (node.matches('pre.sourceCode') && !node.closest('.cell-output')) ||\n              (node.matches('.cell-code') && !node.closest('.cell-output')) ||\n              (node.querySelector && node.querySelector('pre.sourceCode:not(.cell-output pre), .cell-code:not(.cell-output .cell-code)'))\n            )) {\n              shouldRun = true;\n            }\n          }\n        });\n      }\n    });\n    if (shouldRun) {\n      setTimeout(makeCodeBlocksCollapsible, 100);\n    }\n  });\n\n  // Start observing\n  if (document.body) {\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n  } else {\n    document.addEventListener('DOMContentLoaded', function() {\n      observer.observe(document.body, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n})();\n</script>\n"},"output-file":"climate-extremes-explorer.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","python":"/Users/timmwalker/miniforge3/envs/recurrent-analytics/bin/python","jupyter":"python3","collections":{"notes":{"feed":true,"categories":true,"sort":"date desc","listing":{"type":"default","sort":"date desc","contents":"notes/*"}},"projects":{"feed":false,"categories":true,"sort":"date desc","listing":{"type":"default","sort":"date desc","contents":"models/*"}},"tipping-points-notes":{"feed":false,"categories":true,"sort":"date desc","listing":{"type":"default","sort":"date desc","contents":"tipping-points/design-notes/*"}}},"theme":{"light":["cosmo","../styles.scss"],"dark":["cyborg","../styles.scss"]},"code-copy":true,"smooth-scroll":true,"anchor-sections":false,"title":"Climate Extremes Explorer","date":"2025-12-15","categories":["climate","extremes","analysis","visualization"],"description":"Comprehensive interactive analysis of climate extremes using synthetic climate data. Demonstrates methods for identifying, analyzing, and visualizing extreme climate events including heatwaves, cold snaps, and extreme precipitation. Features return period analysis, event clustering, and multi-variable correlation analysis."},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}