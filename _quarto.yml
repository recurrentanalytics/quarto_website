project:
  type: website
  output-dir: _site
  execute-dir: project

website:
  title: "re:current_analytics"
  site-url: https://recurrentanalytics.com
  description: "A lab-notebook for climate risk, models, and recurrent intelligence."
  favicon: assets/favicon.svg

  # Social cards (disabled until image exists)
  # image: assets/social-card.png
  open-graph: true
  twitter-card:
    creator: "@timmwalker"
    # image: assets/social-card.png

  navbar:
    search: true

  page-footer:
    left: "© Timm Walker"

  search: true
  repo-url: https://github.com/recurrentanalytics/recurrentanalytics
  repo-actions: [source]

format:
  html:
    theme:
      light: [cosmo, styles.scss]
      dark:  [cyborg, styles.scss]
    toc: true
    code-tools: true
    code-copy: true
    smooth-scroll: true
    anchor-sections: false
    include-in-header:
      text: |
        <!-- IBM Plex Sans Font -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500&display=swap" rel="stylesheet">
        
        <!-- IBM Plex Mono Font for code blocks -->
        <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;1,400&display=swap" rel="stylesheet">
        
        <!-- Plausible analytics -->
        <script defer data-domain="recurrentanalytics.com" src="https://plausible.io/js/script.js"></script>
        
        <!-- D3.js for network graph -->
        <script src="https://d3js.org/d3.v7.min.js"></script>

        <!-- Hero drift effect -->
        <style>
          .rac-hero {
            position: relative; padding: 5rem 0 4rem; text-align:center;
            overflow: hidden;
          }
          .rac-hero h1 { font-weight: 800; letter-spacing: .5px; }
          .rac-hero .drift {
            position: absolute; left: -10%; right:-10%; bottom: -40px; height: 120px;
            background: radial-gradient(100% 60% at 50% 40%, var(--bs-secondary-bg) 0%, transparent 70%);
            animation: slowfloat 14s ease-in-out infinite alternate;
            opacity:.7; filter: blur(10px);
          }
          @keyframes slowfloat { from { transform: translateY(0px);} to {transform: translateY(16px);} }
        </style>

        <!-- Reading progress bar, keyboard shortcuts -->
        <script>
        document.addEventListener('DOMContentLoaded', function() {
          // Hide page title and reading time on index page
          const path = window.location.pathname;
          const isHomePage = path === '/' || path === '/index.html' || path.endsWith('/index.html');
          
          if (isHomePage) {
            document.body.classList.add('index-page');
            // Hide page title block
            const titleBlock = document.querySelector('.quarto-title-block');
            if (titleBlock) {
              titleBlock.style.display = 'none';
            }
            // Remove any reading time that might have been added
            const readingTime = document.querySelector('.reading-time');
            if (readingTime) {
              readingTime.remove();
            }
          }
          
          // Hide title block on section index pages (projects, notes, reading, tipping-points)
          // These pages have empty titles in YAML and use headings in content instead
          const isSectionIndex = path.match(/\/(projects|notes|reading|tipping-points)\/?$/);
          if (isSectionIndex) {
            const titleBlock = document.querySelector('.quarto-title-block');
            if (titleBlock) {
              titleBlock.style.display = 'none';
            }
            // Also remove reading time on section pages
            const readingTime = document.querySelector('.reading-time');
            if (readingTime) {
              readingTime.remove();
            }
          }
          
          // Breadcrumb navigation
          function createBreadcrumbs() {
            const path = window.location.pathname;
            if (path === '/' || path === '/index.html') return;
            
            const pathParts = path.split('/').filter(p => p && p !== 'index.html');
            const breadcrumbContainer = document.createElement('nav');
            breadcrumbContainer.className = 'breadcrumb-nav';
            breadcrumbContainer.setAttribute('aria-label', 'Breadcrumb');
            
            let breadcrumbHTML = '<ol class="breadcrumb-list">';
            breadcrumbHTML += '<li class="breadcrumb-item"><a href="/">Home</a></li>';
            
            let currentPath = '';
            pathParts.forEach((part, index) => {
              const isLast = index === pathParts.length - 1;
              
              // Special handling for "models" - link to projects page instead
              if (part === 'models' && !isLast) {
                breadcrumbHTML += '<li class="breadcrumb-item"><a href="/projects/">Projects</a></li>';
                return; // Skip adding to currentPath
              }
              
              // Skip "models" in breadcrumb if it's not the last part
              if (part === 'models') {
                return;
              }
              
              currentPath += '/' + part;
              const label = part.replace(/\.html$/, '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
              
              if (isLast) {
                breadcrumbHTML += `<li class="breadcrumb-item active" aria-current="page">${label}</li>`;
              } else {
                breadcrumbHTML += `<li class="breadcrumb-item"><a href="${currentPath}/">${label}</a></li>`;
              }
            });
            
            breadcrumbHTML += '</ol>';
            breadcrumbContainer.innerHTML = breadcrumbHTML;
            
            const contentArea = document.querySelector('#quarto-document-content, .content, main, article');
            if (contentArea) {
              contentArea.insertBefore(breadcrumbContainer, contentArea.firstChild);
            }
          }
          
          createBreadcrumbs();
          
          // Reading progress bar
          const progressBar = document.createElement('div');
          progressBar.className = 'reading-progress';
          document.body.appendChild(progressBar);
          
          window.addEventListener('scroll', function() {
            const scrollTop = window.scrollY;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
            progressBar.style.width = progress + '%';
          });

          // Focus mode for distraction-free reading
          let focusMode = false;
          function toggleFocusMode() {
            focusMode = !focusMode;
            document.body.classList.toggle('focus-mode', focusMode);
            
            // Hide/show elements
            const elementsToHide = document.querySelectorAll('.navbar, .nav-footer, .sidebar, #TOC, #quarto-margin-sidebar, .quarto-back-to-top-link, .mobile-graph-btn, .sidebar-graph');
            elementsToHide.forEach(el => {
              if (el) el.style.display = focusMode ? 'none' : '';
            });
            
            // Update hint
            const hint = document.querySelector('.keyboard-hint');
            if (hint) {
              hint.innerHTML = focusMode 
                ? 'Press f to exit focus mode · Escape to close'
                : '⌘K palette · / search · j/k navigate · f focus · ? hints';
            }
          }

          // Keyboard shortcuts
          const noteLinks = Array.from(document.querySelectorAll('.quarto-listing-default a, .sidebar-item a'));
          let currentIndex = -1;

          document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            // f to toggle focus mode
            if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              toggleFocusMode();
              return;
            }
            
            // / to focus search
            if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              const searchInput = document.querySelector('#quarto-search input, .aa-Input');
              if (searchInput) searchInput.focus();
            }
            
            // j/k to navigate notes (on listing pages)
            if (noteLinks.length > 0) {
              if (e.key === 'j') {
                currentIndex = Math.min(currentIndex + 1, noteLinks.length - 1);
                noteLinks[currentIndex]?.focus();
              }
              if (e.key === 'k') {
                currentIndex = Math.max(currentIndex - 1, 0);
                noteLinks[currentIndex]?.focus();
              }
            }
            
            // ? to show keyboard hints
            if (e.key === '?') {
              const hint = document.querySelector('.keyboard-hint');
              if (hint) hint.classList.toggle('visible');
            }
          });

          // Add keyboard hint element
          const hint = document.createElement('div');
          hint.className = 'keyboard-hint';
          hint.innerHTML = '⌘K palette · / search · j/k navigate · f focus · ? hints';
          document.body.appendChild(hint);

          // Command Palette (Cmd+K / Ctrl+K)
          const pages = [
            { title: 'Home', path: '/' },
            { title: 'About & Contact', path: '/about.html' },
            { title: 'Notes & Knowledge Base', path: '/notes/' },
            { title: 'Projects', path: '/projects/' },
            { title: 'Reading', path: '/reading/' },
            { title: 'Tipping Points', path: '/tipping-points/' },
            { title: 'Hello, Lab', path: '/notes/2025-hello-world.html' },
            { title: 'Risk Modelling Part 1: Foundations', path: '/notes/risk-series-1.html' },
            { title: 'Risk Modelling Part 2: Data', path: '/notes/risk-series-2.html' },
            { title: 'Risk Modelling Part 3: Implementation', path: '/notes/risk-series-3.html' },
            { title: 'Heatwaves and Day-Ahead Prices', path: '/models/heatwave-prices-de-lu.html' }
          ];

          const overlay = document.createElement('div');
          overlay.className = 'cmd-palette-overlay';
          overlay.innerHTML = `
            <div class="cmd-palette">
              <input type="text" class="cmd-palette-input" placeholder="Jump to page...">
              <div class="cmd-palette-results"></div>
            </div>
          `;
          document.body.appendChild(overlay);

          const input = overlay.querySelector('.cmd-palette-input');
          const results = overlay.querySelector('.cmd-palette-results');
          let selectedIndex = 0;

          // Simple fuzzy search function
          function fuzzyMatch(pattern, text) {
            pattern = pattern.toLowerCase();
            text = text.toLowerCase();
            
            // Exact match gets highest score
            if (text.includes(pattern)) return 100;
            
            // Check if all pattern characters appear in order
            let patternIdx = 0;
            let score = 0;
            for (let i = 0; i < text.length && patternIdx < pattern.length; i++) {
              if (text[i] === pattern[patternIdx]) {
                patternIdx++;
                score += 10;
              }
            }
            
            if (patternIdx === pattern.length) {
              return score;
            }
            
            // Check individual word matches
            const words = text.split(/\s+/);
            let wordMatches = 0;
            pattern.split(/\s+/).forEach(pWord => {
              if (words.some(w => w.startsWith(pWord) || w.includes(pWord))) {
                wordMatches++;
              }
            });
            
            return wordMatches * 5;
          }

          function renderResults(filter = '') {
            if (!filter.trim()) {
              const filtered = pages.slice(0, 10);
            results.innerHTML = filtered.map((p, i) => `
              <a href="${p.path}" class="cmd-palette-item ${i === selectedIndex ? 'selected' : ''}">
                <div class="cmd-palette-item-title">${p.title}</div>
                <div class="cmd-palette-item-path">${p.path}</div>
              </a>
            `).join('');
            return filtered;
            }
            
            // Score and sort by relevance
            const scored = pages.map(p => ({
              page: p,
              score: Math.max(
                fuzzyMatch(filter, p.title),
                fuzzyMatch(filter, p.path)
              )
            })).filter(item => item.score > 0)
              .sort((a, b) => b.score - a.score)
              .slice(0, 10);
            
            results.innerHTML = scored.map((item, i) => `
              <a href="${item.page.path}" class="cmd-palette-item ${i === selectedIndex ? 'selected' : ''}">
                <div class="cmd-palette-item-title">${item.page.title}</div>
                <div class="cmd-palette-item-path">${item.page.path}</div>
              </a>
            `).join('');
            return scored.map(item => item.page);
          }

          function openPalette() {
            overlay.classList.add('active');
            input.value = '';
            selectedIndex = 0;
            renderResults();
            setTimeout(() => input.focus(), 50);
          }

          function closePalette() {
            overlay.classList.remove('active');
          }

          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) closePalette();
          });

          input.addEventListener('input', () => {
            selectedIndex = 0;
            renderResults(input.value);
          });

          input.addEventListener('keydown', (e) => {
            const items = results.querySelectorAll('.cmd-palette-item');
            if (e.key === 'ArrowDown') {
              e.preventDefault();
              selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
              renderResults(input.value);
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              selectedIndex = Math.max(selectedIndex - 1, 0);
              renderResults(input.value);
            } else if (e.key === 'Enter') {
              e.preventDefault();
              if (items[selectedIndex]) items[selectedIndex].click();
            } else if (e.key === 'Escape') {
              closePalette();
            }
          });

          document.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
              e.preventDefault();
              if (overlay.classList.contains('active')) {
                closePalette();
              } else {
                openPalette();
              }
            }
            if (e.key === 'Escape' && overlay.classList.contains('active')) {
              closePalette();
            }
          });

          // Reading time - add to article pages (but not on index/home page, notes index, or about page)
          // Reuse path from earlier in the scope
          const isHomePageForReading = path === '/' || path === '/index.html' || path.endsWith('/index.html');
          const isNotesIndex = path === '/notes/' || path === '/notes/index.html' || path.endsWith('/notes/index.html');
          const isAboutPage = path === '/about.html' || path.endsWith('/about.html');
          
          if (!isHomePageForReading && !isNotesIndex && !isAboutPage) {
          const articleBody = document.querySelector('.quarto-title-block, #quarto-document-content');
          const contentArea = document.querySelector('#quarto-document-content, .content, main');
          if (articleBody && contentArea) {
            const text = contentArea.innerText || '';
            const wordCount = text.trim().split(/\s+/).length;
            const readingTime = Math.max(1, Math.ceil(wordCount / 200));
            const timeSpan = document.createElement('span');
            timeSpan.className = 'reading-time';
            timeSpan.textContent = readingTime + ' min read';
            const titleMeta = document.querySelector('.quarto-title-meta, .quarto-title');
            if (titleMeta) {
              titleMeta.appendChild(document.createTextNode(' · '));
              titleMeta.appendChild(timeSpan);
            }
          }
          }


          // Network Graph visualization
          console.log('Starting graph navigation setup...');
          const graphData = {
            nodes: [
              { id: 'home', label: 'Home', path: '/', cat: 'nav' },
              { id: 'about', label: 'About & Contact', path: '/about.html', cat: 'nav' },
              { id: 'notes', label: 'Notes', path: '/notes/', cat: 'nav' },
              { id: 'hello', label: 'Hello, Lab', path: '/notes/2025-hello-world.html', cat: 'notes' },
              { id: 'risk-1', label: 'Risk Part 1', path: '/notes/risk-series-1.html', cat: 'notes' },
              { id: 'risk-2', label: 'Risk Part 2', path: '/notes/risk-series-2.html', cat: 'notes' },
              { id: 'risk-3', label: 'Risk Part 3', path: '/notes/risk-series-3.html', cat: 'notes' },
              { id: 'heatwave', label: 'Heatwave Prices', path: '/models/heatwave-prices-de-lu.html', cat: 'projects' },
              { id: 'climate-extremes', label: 'Climate Extremes Explorer', path: '/models/climate-extremes-explorer.html', cat: 'projects' },
              { id: 'projects', label: 'Projects', path: '/projects/', cat: 'nav' },
              { id: 'tipping-points', label: 'Tipping Points', path: '/tipping-points/', cat: 'nav' }
            ],
            links: [
              { source: 'home', target: 'notes' },
              { source: 'home', target: 'projects' },
              { source: 'home', target: 'tipping-points' },
              { source: 'home', target: 'about' },
              { source: 'notes', target: 'hello' },
              { source: 'notes', target: 'risk-1' },
              { source: 'risk-1', target: 'risk-2' },
              { source: 'risk-2', target: 'risk-1' },
              { source: 'risk-2', target: 'risk-3' },
              { source: 'risk-2', target: 'heatwave' },
              { source: 'risk-3', target: 'risk-1' },
              { source: 'risk-3', target: 'risk-2' },
              { source: 'projects', target: 'heatwave' },
              { source: 'projects', target: 'climate-extremes' },
              { source: 'heatwave', target: 'risk-2' },
              { source: 'climate-extremes', target: 'risk-2' },
            ]
          };
          
          // Category colors for graph nodes
          const catColors = {
            nav: 'var(--bs-secondary)',
            notes: 'var(--bs-info)',
            projects: 'var(--bs-success)'
          };

          // Create sidebar mini-graph widget - always add to body to ensure it's on all pages
          const sidebarGraph = document.createElement('div');
          sidebarGraph.className = 'sidebar-graph';
          sidebarGraph.title = 'Click to expand';
          sidebarGraph.innerHTML = `
            <div class="sidebar-graph-header">
              <span class="sidebar-graph-title">Connections</span>
              <span class="sidebar-graph-expand">expand</span>
            </div>
            <div class="sidebar-graph-container" id="mini-graph-container"></div>
          `;
          
          // Try to add to sidebar first, but always ensure it's in the DOM
          console.log('Appending sidebar graph to DOM...');
          const sidebar = document.querySelector('#quarto-margin-sidebar, .sidebar, #TOC');
          if (sidebar) {
            console.log('Sidebar found, appending to sidebar');
            sidebar.appendChild(sidebarGraph);
          } else {
            // If no sidebar, add as fixed element to body
            console.log('No sidebar found, appending to body as fixed element');
            document.body.appendChild(sidebarGraph);
            sidebarGraph.style.position = 'fixed';
            sidebarGraph.style.bottom = '1rem';
            sidebarGraph.style.right = '1rem';
            sidebarGraph.style.width = '200px';
            sidebarGraph.style.zIndex = '100';
          }
          console.log('Sidebar graph in DOM:', document.body.contains(sidebarGraph) || (sidebar && sidebar.contains(sidebarGraph)));
          
          // Ensure sidebar graph is always accessible even if sidebar is hidden
          // Add a fallback fixed position version if sidebar doesn't exist
          if (!sidebar) {
            sidebarGraph.style.display = 'block';
            sidebarGraph.style.visibility = 'visible';
          }
          
          // Force visibility
          sidebarGraph.style.display = 'block';
          sidebarGraph.style.visibility = 'visible';
          sidebarGraph.style.opacity = '1';
          
          // Ensure sidebarGraph is clickable - attach handler after it's in DOM
          setTimeout(function() {
            const graphEl = document.querySelector('.sidebar-graph');
            if (graphEl && !graphEl.hasAttribute('data-click-handler-attached')) {
              graphEl.setAttribute('data-click-handler-attached', 'true');
              graphEl.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (typeof window.openGraphNavigation === 'function') {
                  window.openGraphNavigation();
                }
              });
            }
          }, 100);

          // Create modal FIRST - before any D3 checks
          console.log('Creating graph modal element...');
          const graphModal = document.createElement('div');
          graphModal.className = 'graph-modal-overlay';
          graphModal.innerHTML = `
            <div class="graph-modal">
              <div class="graph-modal-header">
                <span class="graph-modal-title">Note Connections</span>
                <button class="graph-modal-close">&times;</button>
              </div>
              <div class="graph-modal-controls">
                <input type="text" class="graph-search-input" placeholder="Search nodes..." id="graph-search">
                <div class="graph-category-filters">
                  <button class="graph-filter-btn active" data-cat="all">All</button>
                  <button class="graph-filter-btn" data-cat="nav">Nav</button>
                  <button class="graph-filter-btn" data-cat="notes">Notes</button>
                  <button class="graph-filter-btn" data-cat="projects">Projects</button>
                </div>
                <div class="graph-zoom-controls">
                  <button class="graph-zoom-btn" id="zoom-in" title="Zoom in">+</button>
                  <button class="graph-zoom-btn" id="zoom-out" title="Zoom out">−</button>
                  <button class="graph-zoom-btn" id="zoom-reset" title="Reset zoom">⌂</button>
                </div>
              </div>
              <div class="graph-container" id="graph-container"></div>
            </div>
          `;
          document.body.appendChild(graphModal);

          function getCurrentPageId() {
            const path = window.location.pathname;
            const node = graphData.nodes.find(n => path.endsWith(n.path) || path === n.path || 
              (n.path === '/' && (path === '/' || path === '/index.html' || path.endsWith('/index.html'))));
            return node ? node.id : null;
          }
          
          // Make getCurrentPageId and graphData available globally
          window.getCurrentPageId = getCurrentPageId;
          window.graphData = graphData;

          function openGraph() {
            console.log('openGraph called', { graphModal: !!graphModal, inDOM: graphModal && document.body.contains(graphModal) });
            
            // Ensure graph modal exists
            if (!graphModal) {
              console.error('Graph modal not found!');
              return;
            }
            
            if (!document.body.contains(graphModal)) {
              console.warn('Graph modal not in DOM, appending...');
              document.body.appendChild(graphModal);
            }
            
            // Ensure modal is visible
            graphModal.style.display = 'flex';
            graphModal.style.visibility = 'visible';
            graphModal.classList.add('active');
            
            // Initialize graph if not already done
            if (typeof initGraph === 'function') {
            initGraph();
            } else {
              console.error('initGraph function not found');
            }
            
            // Focus trap - prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
          }

          function closeGraph() {
            if (graphModal) {
            graphModal.classList.remove('active');
              // Restore body scroll
              document.body.style.overflow = '';
            }
          }
          
          // Make openGraph globally available so it can be called from anywhere
          window.openGraphNavigation = openGraph;

          // Ensure event listeners are attached after elements are created
          // Use event delegation to handle clicks on sidebar graph
          if (sidebarGraph && sidebarGraph.parentNode) {
            sidebarGraph.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              if (typeof openGraph === 'function') {
              openGraph();
              } else if (typeof window.openGraphNavigation === 'function') {
                window.openGraphNavigation();
            }
          });
          } else {
            // If sidebarGraph isn't in DOM yet, wait and retry
            setTimeout(function() {
              const graph = document.querySelector('.sidebar-graph');
              if (graph) {
                graph.addEventListener('click', function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  if (typeof window.openGraphNavigation === 'function') {
                    window.openGraphNavigation();
                  }
                });
              }
            }, 500);
          }
          
          const closeBtn = graphModal.querySelector('.graph-modal-close');
          if (closeBtn) {
            closeBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              closeGraph();
            });
          }
          
          graphModal.addEventListener('click', function(e) {
            if (e.target === graphModal) {
              closeGraph();
            }
          });
          
          // Global keyboard shortcut - attach to document, not just inside DOMContentLoaded
          function handleGraphKeyboard(e) {
            // Escape to close graph modal
            if (e.key === 'Escape' && graphModal && graphModal.classList.contains('active')) {
              closeGraph();
              return;
            }
            // 'g' key to open graph - works everywhere except in input fields
            if ((e.key === 'g' || e.key === 'G') && 
                e.target.tagName !== 'INPUT' && 
                e.target.tagName !== 'TEXTAREA' && 
                !e.ctrlKey && 
                !e.metaKey && 
                !e.altKey &&
                !e.shiftKey) {
              e.preventDefault();
              e.stopPropagation();
              openGraph();
            }
          }
          
          console.log('Attaching keyboard handler...');
          document.addEventListener('keydown', handleGraphKeyboard);
          console.log('Keyboard handler attached to document');
          
          // Also attach to window for extra reliability
          window.addEventListener('keydown', handleGraphKeyboard);
          console.log('Keyboard handler attached to window');
          
          // Test: Try calling openGraph directly to verify it works
          console.log('openGraph function available:', typeof openGraph);
          console.log('window.openGraphNavigation available:', typeof window.openGraphNavigation);

          // Render mini-graph in sidebar immediately using D3-force
          function renderMiniGraph() {
            const container = document.getElementById('mini-graph-container');
            if (!container || typeof d3 === 'undefined') return;
            
            const width = container.clientWidth || 180;
            const height = container.clientHeight || 150;
            const currentId = getCurrentPageId();

            const svg = d3.select(container).append('svg')
              .attr('viewBox', `0 0 ${width} ${height}`);

            const nodes = graphData.nodes.map(d => ({...d}));
            const links = graphData.links.map(d => ({source: d.source, target: d.target}));

            const connectedNodes = new Set();
            graphData.links.forEach(l => {
              if (l.source === currentId || l.target === currentId) {
                connectedNodes.add(l.source);
                connectedNodes.add(l.target);
              }
            });

            // Find current node and center it
            const currentNode = nodes.find(n => n.id === currentId);
            const centerX = width / 2;
            const centerY = height / 2;
            
            if (currentNode) {
              // Set current node to center
              currentNode.fx = centerX;
              currentNode.fy = centerY;
            }

            // D3 force simulation for mini graph
            const simulation = d3.forceSimulation(nodes)
              .force('link', d3.forceLink(links).id(d => d.id).distance(30))
              .force('charge', d3.forceManyBody().strength(-60))
              .force('center', d3.forceCenter(centerX, centerY))
              .force('collision', d3.forceCollide().radius(10))
              .stop();

            // Run simulation synchronously for static layout
            for (let i = 0; i < 100; i++) simulation.tick();

            // Clamp positions (except current node which stays fixed)
            nodes.forEach(n => {
              if (n.id !== currentId) {
              n.x = Math.max(15, Math.min(width - 15, n.x));
              n.y = Math.max(15, Math.min(height - 15, n.y));
              }
            });
            
            // Release fixed position after simulation
            if (currentNode) {
              currentNode.fx = null;
              currentNode.fy = null;
            }

            // Draw links
            svg.selectAll('line')
              .data(links)
              .join('line')
              .attr('x1', d => d.source.x)
              .attr('y1', d => d.source.y)
              .attr('x2', d => d.target.x)
              .attr('y2', d => d.target.y)
              .attr('class', d => 'graph-link' + (connectedNodes.has(d.source.id) && connectedNodes.has(d.target.id) ? ' connected' : ''));

            // Draw nodes with hover tooltip
            const nodeGroups = svg.selectAll('g.mini-node')
              .data(nodes)
              .join('g')
              .attr('class', 'mini-node')
              .attr('transform', d => `translate(${d.x},${d.y})`);

            nodeGroups.append('circle')
              .attr('r', d => d.id === currentId ? 6 : (connectedNodes.has(d.id) ? 4 : 3))
              .attr('fill', d => d.id === currentId ? 'var(--bs-primary)' : (catColors[d.cat] || 'var(--bs-secondary)'))
              .attr('class', d => 'graph-node' + (d.id === currentId ? ' current' : ''));

            // Tooltip on hover
            const tooltip = d3.select(container).append('div')
              .attr('class', 'mini-graph-tooltip')
              .style('opacity', 0);

            nodeGroups
              .on('mouseenter', (event, d) => {
                tooltip.text(d.label)
                  .style('left', (d.x + 10) + 'px')
                  .style('top', (d.y - 5) + 'px')
                  .style('opacity', 1);
              })
              .on('mouseleave', () => tooltip.style('opacity', 0));
          }
          
          // Render mini graph - ensure it runs
          function tryRenderMiniGraph() {
            const container = document.getElementById('mini-graph-container');
            if (!container) {
              console.warn('Mini graph container not found');
              return false;
            }
            if (typeof d3 === 'undefined') {
              console.warn('D3.js not loaded yet');
              return false;
            }
            if (!graphData) {
              console.warn('Graph data not available');
              return false;
            }
            try {
          renderMiniGraph();
              console.log('Mini graph rendered successfully');
              return true;
            } catch (error) {
              console.error('Error rendering mini graph:', error);
              return false;
            }
          }
          
          // Try immediately
          if (!tryRenderMiniGraph()) {
            // Wait for D3 to load
            let attempts = 0;
            const checkD3 = setInterval(() => {
              attempts++;
              if (tryRenderMiniGraph() || attempts > 50) {
                clearInterval(checkD3);
              }
            }, 100);
          }

          // Mobile floating graph button - always available as fallback
          const mobileGraphBtn = document.createElement('button');
          mobileGraphBtn.className = 'mobile-graph-btn';
          mobileGraphBtn.innerHTML = '&#x1F578;'; // spider web emoji as graph icon
          mobileGraphBtn.title = 'View connections (or press g)';
          mobileGraphBtn.setAttribute('aria-label', 'Open connection graph');
          mobileGraphBtn.type = 'button'; // Prevent form submission
          mobileGraphBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            openGraph();
          });
          document.body.appendChild(mobileGraphBtn);
          
          // Ensure mobile button is always in DOM and accessible
          mobileGraphBtn.style.display = 'none'; // Hidden by default, shown via CSS on mobile
          
          // Debug: Log that graph navigation is initialized
          console.log('Graph navigation initialized:', {
            sidebarGraph: !!sidebarGraph,
            graphModal: !!graphModal,
            mobileGraphBtn: !!mobileGraphBtn,
            openGraph: typeof openGraph,
            graphData: !!graphData,
            d3Loaded: typeof d3 !== 'undefined',
            sidebarGraphElement: document.querySelector('.sidebar-graph'),
            miniGraphContainer: document.getElementById('mini-graph-container')
          });
          
          // Ensure sidebar graph is visible
          if (sidebarGraph) {
            console.log('Sidebar graph element created:', sidebarGraph);
            sidebarGraph.style.display = 'block';
            sidebarGraph.style.visibility = 'visible';
            sidebarGraph.style.opacity = '1';
          }
          
          // Test: Make sure openGraph is callable
          console.log('Testing openGraph function:', typeof openGraph);
          if (typeof openGraph === 'function') {
            console.log('openGraph is a function - good!');
          } else {
            console.error('openGraph is not a function!', openGraph);
          }
          
          // Test: Make sure keyboard handler is attached
          console.log('Keyboard handler attached:', typeof handleGraphKeyboard);
          
          // Test: Try to manually trigger openGraph after a short delay to verify it works
          setTimeout(() => {
            console.log('Testing graph system after 1 second...');
            const testModal = document.querySelector('.graph-modal-overlay');
            const testSidebar = document.querySelector('.sidebar-graph');
            const testBtn = document.querySelector('.mobile-graph-btn');
            console.log('Elements found:', {
              modal: !!testModal,
              sidebar: !!testSidebar,
              button: !!testBtn
            });
          }, 1000);

          let graphInitialized = false;
          let currentGraphState = { nodes: [], links: [], svg: null, simulation: null };
          let activeCategory = 'all';
          let searchFilter = '';
          
          let zoomBehavior = null;
          let currentTransform = d3.zoomIdentity;
          
          function initGraph() {
            console.log('initGraph called', { graphInitialized, d3Loaded: typeof d3 !== 'undefined' });
            if (graphInitialized || typeof d3 === 'undefined') {
              console.warn('initGraph skipped:', { graphInitialized, d3Loaded: typeof d3 !== 'undefined' });
              return;
            }
            graphInitialized = true;
            console.log('Rendering full graph...');
            renderGraph();
            
            // Setup search and filters
            const searchInput = document.getElementById('graph-search');
            if (searchInput) {
              searchInput.addEventListener('input', (e) => {
                searchFilter = e.target.value.toLowerCase();
                renderGraph();
              });
            }
            
            const filterBtns = document.querySelectorAll('.graph-filter-btn');
            filterBtns.forEach(btn => {
              btn.addEventListener('click', () => {
                filterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                activeCategory = btn.dataset.cat;
                renderGraph();
              });
            });
            
            // Setup zoom controls
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');
            const zoomResetBtn = document.getElementById('zoom-reset');
            
            if (zoomInBtn) {
              zoomInBtn.addEventListener('click', () => {
            const container = document.getElementById('graph-container');
                const svg = d3.select(container).select('svg');
                if (svg && zoomBehavior) {
                  svg.transition().call(zoomBehavior.scaleBy, 1.5);
                }
              });
            }
            
            if (zoomOutBtn) {
              zoomOutBtn.addEventListener('click', () => {
                const container = document.getElementById('graph-container');
                const svg = d3.select(container).select('svg');
                if (svg && zoomBehavior) {
                  svg.transition().call(zoomBehavior.scaleBy, 1 / 1.5);
                }
              });
            }
            
            if (zoomResetBtn) {
              zoomResetBtn.addEventListener('click', () => {
                const container = document.getElementById('graph-container');
                const svg = d3.select(container).select('svg');
                if (svg && zoomBehavior) {
                  svg.transition().call(zoomBehavior.transform, d3.zoomIdentity);
                }
              });
            }
          }
          
          function renderGraph() {
            const container = document.getElementById('graph-container');
            if (!container) return;
            
            // Clear existing graph
            d3.select(container).selectAll('*').remove();
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            const currentId = getCurrentPageId();

            const svg = d3.select(container).append('svg')
              .attr('width', width)
              .attr('height', height);

            // Create a group for all graph elements (for zoom/pan)
            const g = svg.append('g');
            
            // Create zoom behavior
            zoomBehavior = d3.zoom()
              .scaleExtent([0.3, 3])
              .on('zoom', function(event) {
                currentTransform = event.transform;
                g.attr('transform', event.transform);
              });

            // Apply zoom to svg
            svg.call(zoomBehavior);

            // Filter nodes by category and search
            let filteredNodes = graphData.nodes.map(d => ({
              ...d,
              id: String(d.id)  // Ensure all node IDs are strings
            }));
            if (activeCategory !== 'all') {
              filteredNodes = filteredNodes.filter(n => n.cat === activeCategory);
            }
            if (searchFilter) {
              filteredNodes = filteredNodes.filter(n => 
                n.label.toLowerCase().includes(searchFilter) || 
                n.path.toLowerCase().includes(searchFilter)
              );
            }
            
            const nodeIds = new Set(filteredNodes.map(n => String(n.id)));
            
            // Filter links to only include filtered nodes
            // Create new link objects with string IDs for D3 forceLink
            const filteredLinks = graphData.links
              .filter(l => {
                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                return nodeIds.has(sourceId) && nodeIds.has(targetId);
              })
              .map(l => {
                // Create new objects with string IDs (don't reference original)
                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                return {source: String(sourceId), target: String(targetId)};
              });

            // Find connected nodes and paths
            const connectedNodes = new Set();
            const paths = new Map();
            
            graphData.links.forEach(l => {
              const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
              const targetId = typeof l.target === 'object' ? l.target.id : l.target;
              
              if (sourceId === currentId || targetId === currentId) {
                connectedNodes.add(sourceId);
                connectedNodes.add(targetId);
              }
              
              // Build path map for highlighting
              if (!paths.has(sourceId)) paths.set(sourceId, new Set());
              paths.get(sourceId).add(targetId);
              if (!paths.has(targetId)) paths.set(targetId, new Set());
              paths.get(targetId).add(sourceId);
            });
            
            // Find all nodes in paths from current
            function findPathNodes(startId, visited = new Set()) {
              if (visited.has(startId)) return visited;
              visited.add(startId);
              const neighbors = paths.get(startId) || new Set();
              neighbors.forEach(neighbor => {
                if (nodeIds.has(neighbor)) {
                  findPathNodes(neighbor, visited);
              }
            });
              return visited;
            }
            
            const pathNodes = currentId ? findPathNodes(currentId) : new Set();

            // Find current node and center it
            const currentNode = filteredNodes.find(n => String(n.id) === String(currentId));
            const centerX = width / 2;
            const centerY = height / 2;
            
            if (currentNode) {
              // Set current node to center and fix it there
              currentNode.fx = centerX;
              currentNode.fy = centerY;
            }

            // D3 force simulation for full graph - centered on current node
            // Create a map for quick node lookup by ID
            const nodeMap = new Map(filteredNodes.map(n => [String(n.id), n]));
            
            // Ensure all links reference valid node IDs (filteredLinks already has string IDs)
            const validLinks = filteredLinks.filter(l => {
              const sourceId = String(l.source);
              const targetId = String(l.target);
              return nodeMap.has(sourceId) && nodeMap.has(targetId);
            }).map(l => ({
              // Create fresh objects to avoid mutation issues
              source: String(l.source),
              target: String(l.target)
            }));
            
            const simulation = d3.forceSimulation(filteredNodes)
              .force('link', d3.forceLink(validLinks).id(d => String(d.id)).distance(80))
              .force('charge', d3.forceManyBody().strength(-200))
              .force('center', d3.forceCenter(centerX, centerY))
              .force('collision', d3.forceCollide().radius(25))
              .stop();

            // Run simulation synchronously
            for (let i = 0; i < 150; i++) simulation.tick();

            // Clamp positions (except current node which stays fixed at center)
            filteredNodes.forEach(n => {
              if (String(n.id) !== String(currentId)) {
              n.x = Math.max(50, Math.min(width - 50, n.x));
              n.y = Math.max(50, Math.min(height - 50, n.y));
              }
            });
            
            // Keep current node at center (don't release fixed position)
            // This ensures it stays centered even if simulation continues
            if (currentNode) {
              currentNode.fx = centerX;
              currentNode.fy = centerY;
            }

            // Draw links with path highlighting (inside the g group for zoom/pan)
            // After simulation, D3 mutates validLinks: source/target are now node objects
            g.selectAll('line.graph-link')
              .data(validLinks)
              .join('line')
              .attr('class', 'graph-link')
              .attr('x1', d => {
                // After simulation, source/target are node objects with x/y properties
                if (d.source && typeof d.source === 'object' && typeof d.source.x === 'number') {
                  return d.source.x;
                }
                // Fallback: find node by ID if source is still a string
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const sourceNode = filteredNodes.find(n => String(n.id) === String(sourceId));
                return sourceNode && typeof sourceNode.x === 'number' ? sourceNode.x : 0;
              })
              .attr('y1', d => {
                if (d.source && typeof d.source === 'object' && typeof d.source.y === 'number') {
                  return d.source.y;
                }
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const sourceNode = filteredNodes.find(n => String(n.id) === String(sourceId));
                return sourceNode && typeof sourceNode.y === 'number' ? sourceNode.y : 0;
              })
              .attr('x2', d => {
                if (d.target && typeof d.target === 'object' && typeof d.target.x === 'number') {
                  return d.target.x;
                }
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                const targetNode = filteredNodes.find(n => String(n.id) === String(targetId));
                return targetNode && typeof targetNode.x === 'number' ? targetNode.x : 0;
              })
              .attr('y2', d => {
                if (d.target && typeof d.target === 'object' && typeof d.target.y === 'number') {
                  return d.target.y;
                }
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                const targetNode = filteredNodes.find(n => String(n.id) === String(targetId));
                return targetNode && typeof targetNode.y === 'number' ? targetNode.y : 0;
              })
              .attr('class', d => {
                // Get IDs from node objects (after simulation) or fallback to string IDs
                const sourceId = d.source && typeof d.source === 'object' ? String(d.source.id) : String(d.source);
                const targetId = d.target && typeof d.target === 'object' ? String(d.target.id) : String(d.target);
                const bothConnected = connectedNodes.has(sourceId) && connectedNodes.has(targetId);
                const bothInPath = pathNodes.has(sourceId) && pathNodes.has(targetId);
                return 'graph-link' + (bothConnected ? ' connected' : '') + (bothInPath ? ' path' : '');
              });

            // Draw nodes with labels (inside the g group for zoom/pan)
            const nodeGroups = g.selectAll('g.graph-node')
              .data(filteredNodes)
              .join('g')
              .attr('class', d => {
                const isCurrent = d.id === currentId;
                const isConnected = connectedNodes.has(d.id);
                const isInPath = pathNodes.has(d.id);
                return 'graph-node' + 
                  (isCurrent ? ' current' : '') + 
                  (isConnected ? ' connected' : '') +
                  (isInPath ? ' path' : '');
              })
              .attr('transform', d => `translate(${d.x},${d.y})`)
              .style('cursor', 'pointer')
              .on('click', (event, d) => { window.location.href = d.path; });

            nodeGroups.append('circle')
              .attr('r', d => {
                if (d.id === currentId) return 10;
                if (connectedNodes.has(d.id)) return 8;
                if (pathNodes.has(d.id)) return 7;
                return 6;
              })
              .attr('fill', d => {
                if (d.id === currentId) return '#20B2AA';  /* True Teal */
                if (connectedNodes.has(d.id)) return catColors[d.cat] || 'var(--bs-secondary)';
                if (pathNodes.has(d.id)) return catColors[d.cat] || 'var(--bs-secondary)';
                return catColors[d.cat] || 'var(--bs-secondary)';
              })
              .attr('opacity', d => {
                if (d.id === currentId) return 1;
                if (connectedNodes.has(d.id)) return 1;
                if (pathNodes.has(d.id)) return 0.8;
                return 0.5;
              });

            nodeGroups.append('text')
              .attr('y', 20)
              .text(d => d.label);
            
            currentGraphState = { nodes: filteredNodes, links: filteredLinks, svg, simulation };
          }
        });
        </script>

        <!-- Image Lightbox/Modal for clickable enlargements -->
        <style>
        /* Lightbox overlay */
        .image-lightbox {
          display: none;
          position: fixed;
          z-index: 10000;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.9);
          cursor: pointer;
          opacity: 0;
          transition: opacity 0.3s ease;
        }

        .image-lightbox.active {
          display: flex;
          align-items: center;
          justify-content: center;
          opacity: 1;
        }

        .image-lightbox-content {
          max-width: 95%;
          max-height: 95%;
          margin: auto;
          display: block;
          object-fit: contain;
          cursor: default;
        }

        .image-lightbox-close {
          position: absolute;
          top: 20px;
          right: 35px;
          color: #f1f1f1;
          font-size: 40px;
          font-weight: bold;
          cursor: pointer;
          z-index: 10001;
          line-height: 1;
          transition: color 0.2s;
        }

        .image-lightbox-close:hover,
        .image-lightbox-close:focus {
          color: #fff;
          text-decoration: none;
        }

        /* Make figures and images clickable */
        .quarto-figure,
        figure,
        .cell-output-display img,
        .cell-output-display svg,
        .quarto-plot img,
        img[src*=".png"],
        img[src*=".jpg"],
        img[src*=".jpeg"],
        img[src*=".svg"] {
          cursor: pointer;
          transition: opacity 0.2s;
        }

        .quarto-figure:hover,
        figure:hover,
        .cell-output-display img:hover,
        .cell-output-display svg:hover,
        .quarto-plot img:hover,
        img[src*=".png"]:hover,
        img[src*=".jpg"]:hover,
        img[src*=".jpeg"]:hover,
        img[src*=".svg"]:hover {
          opacity: 0.9;
        }

        /* Exclude icons and small images */
        .navbar img,
        .nav-footer img,
        img[width][width<100],
        img[height][height<100] {
          cursor: default;
        }
        </style>

        <script>
        document.addEventListener('DOMContentLoaded', function() {
          // Create lightbox element
          const lightbox = document.createElement('div');
          lightbox.className = 'image-lightbox';
          lightbox.innerHTML = '<span class="image-lightbox-close">&times;</span><img class="image-lightbox-content" src="" alt="">';
          document.body.appendChild(lightbox);

          const lightboxImg = lightbox.querySelector('img');
          const lightboxClose = lightbox.querySelector('.image-lightbox-close');

          // Function to open lightbox
          function openLightbox(imgSrc, imgAlt) {
            lightboxImg.src = imgSrc;
            lightboxImg.alt = imgAlt || '';
            lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
          }

          // Function to close lightbox
          function closeLightbox() {
            lightbox.classList.remove('active');
            document.body.style.overflow = '';
          }

          // Close on X click
          lightboxClose.addEventListener('click', closeLightbox);

          // Close on overlay click
          lightbox.addEventListener('click', function(e) {
            if (e.target === lightbox) {
              closeLightbox();
            }
          });

          // Close on Escape key
          document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && lightbox.classList.contains('active')) {
              closeLightbox();
            }
          });

          // Make all figures and images clickable
          const selectors = [
            '.quarto-figure img',
            'figure img',
            '.cell-output-display img',
            '.cell-output-display svg',
            '.quarto-plot img',
            '.quarto-figure svg',
            'figure svg'
          ];

          selectors.forEach(selector => {
            document.querySelectorAll(selector).forEach(img => {
              // Skip small images (likely icons)
              if (img.width && img.width < 100) return;
              if (img.height && img.height < 100) return;
              
              // Skip navbar/footer images
              if (img.closest('.navbar') || img.closest('.nav-footer')) return;

              img.style.cursor = 'pointer';
              img.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const src = this.src || this.getAttribute('data-src') || this.href;
                if (src) {
                  openLightbox(src, this.alt || '');
                }
              });
            });
          });

          // Also handle figure containers
          document.querySelectorAll('.quarto-figure, figure').forEach(figure => {
            const img = figure.querySelector('img, svg');
            if (img && !img.closest('.navbar') && !img.closest('.nav-footer')) {
              figure.style.cursor = 'pointer';
              figure.addEventListener('click', function(e) {
                if (e.target.tagName !== 'IMG' && e.target.tagName !== 'SVG') {
                  const img = this.querySelector('img, svg');
                  if (img) {
                    e.preventDefault();
                    e.stopPropagation();
                    const src = img.src || img.getAttribute('data-src') || img.href;
                    if (src) {
                      openLightbox(src, img.alt || '');
                    }
                  }
                }
              });
            }
          });

          // Back to top button
          (function() {
            const backToTopBtn = document.createElement('button');
            backToTopBtn.className = 'back-to-top-btn';
            backToTopBtn.innerHTML = '↑';
            backToTopBtn.setAttribute('aria-label', 'Back to top');
            backToTopBtn.setAttribute('title', 'Back to top');
            backToTopBtn.type = 'button';
            
            if (document.body) {
              document.body.appendChild(backToTopBtn);
            } else {
              // Wait for body if not ready
              setTimeout(function() {
                document.body.appendChild(backToTopBtn);
              }, 100);
            }

            function updateBackToTopVisibility() {
              if (!backToTopBtn.parentNode) return;
              const scrollY = window.pageYOffset || document.documentElement.scrollTop || window.scrollY || 0;
              if (scrollY > 300) {
                backToTopBtn.classList.add('visible');
              } else {
                backToTopBtn.classList.remove('visible');
              }
            }

            // Use both scroll events for better compatibility
            window.addEventListener('scroll', updateBackToTopVisibility, { passive: true });
            document.addEventListener('scroll', updateBackToTopVisibility, { passive: true });
            updateBackToTopVisibility(); // Check on load

            backToTopBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              // Try multiple scroll methods for compatibility
              if (window.scrollTo) {
                window.scrollTo({
                  top: 0,
                  behavior: 'smooth'
                });
              } else if (document.documentElement.scrollTo) {
                document.documentElement.scrollTo({
                  top: 0,
                  behavior: 'smooth'
                });
              } else {
                // Fallback
                window.scrollTo(0, 0);
              }
            });
          })();


          // Related Notes Section
          function addRelatedNotes() {
            // Only on note pages (not index, not projects, etc.)
            const path = window.location.pathname;
            const isNotePage = path.startsWith('/notes/') && 
                              !path.endsWith('/notes/') && 
                              !path.endsWith('/notes/index.html') &&
                              path.includes('.html');
            
            if (!isNotePage) return;

            // Get current page categories from meta tags or page data
            const currentCategories = [];
            const currentTags = [];
            
            // Try to get from meta tags
            const categoryMeta = document.querySelector('meta[name="categories"], meta[property="article:tag"]');
            if (categoryMeta) {
              const cats = categoryMeta.content.split(',').map(c => c.trim());
              currentCategories.push(...cats);
            }
            
            // Try to get from page data attributes
            const pageData = document.querySelector('[data-categories]');
            if (pageData) {
              const cats = pageData.getAttribute('data-categories').split(',').map(c => c.trim());
              currentCategories.push(...cats);
            }

            // Get all notes from search.json or listings
            fetch('/search.json')
              .then(response => response.json())
              .then(data => {
                // Extract unique note pages
                const notePages = new Map();
                data.forEach(item => {
                  if (item.href && item.href.startsWith('/notes/') && 
                      !item.href.endsWith('/notes/index.html') &&
                      item.href.includes('.html') &&
                      !item.section) { // Only main pages, not sections
                    if (!notePages.has(item.href) || !notePages.get(item.href).title) {
                      notePages.set(item.href, {
                        href: item.href,
                        title: item.title || 'Untitled',
                        text: item.text || ''
                      });
                    }
                  }
                });

                // Find related notes (simple: same title words or series)
                const currentTitle = document.querySelector('h1, .quarto-title h1')?.textContent || '';
                const currentText = document.body.innerText || '';
                const currentTitleWords = currentTitle.toLowerCase().split(/\s+/);
                
                const related = Array.from(notePages.values())
                  .filter(note => {
                    // Don't include current page
                    if (note.href === path || note.href === path.replace('.html', '')) return false;
                    
                    // Check for shared words in title
                    const noteTitleWords = note.title.toLowerCase().split(/\s+/);
                    const sharedWords = currentTitleWords.filter(w => 
                      w.length > 3 && noteTitleWords.includes(w)
                    );
                    
                    // Check for series (e.g., "Part 1", "Part 2")
                    const isSeries = /part\s+\d+/i.test(currentTitle) && /part\s+\d+/i.test(note.title);
                    
                    return sharedWords.length > 0 || isSeries || 
                           (currentText.includes('risk') && note.text.toLowerCase().includes('risk')) ||
                           (currentText.includes('climate') && note.text.toLowerCase().includes('climate'));
                  })
                  .slice(0, 5); // Limit to 5 related notes

                if (related.length > 0) {
                  // Create related notes section
                  const relatedSection = document.createElement('div');
                  relatedSection.className = 'related-notes-section';
                  relatedSection.innerHTML = `
                    <h2 class="related-notes-heading">Related Notes</h2>
                    <ul class="related-notes-list">
                      ${related.map(note => `
                        <li>
                          <a href="${note.href}">${note.title}</a>
                        </li>
                      `).join('')}
                    </ul>
                  `;

                  // Insert before footer or at end of content
                  const content = document.querySelector('#quarto-document-content, .content, main, article');
                  if (content) {
                    content.appendChild(relatedSection);
                  }
                }
              })
              .catch(err => console.log('Could not load related notes:', err));
          }

          // Run after page load
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', addRelatedNotes);
          } else {
            addRelatedNotes();
          }
        });
        </script>

        <style>
        /* Related Notes Section */
        .related-notes-section {
          margin-top: 3rem;
          padding-top: 2rem;
          border-top: 1px solid var(--bs-border-color);
        }

        .related-notes-heading {
          font-size: 1.25rem;
          font-weight: 600;
          margin-bottom: 1rem;
          color: var(--bs-body-color);
        }

        .related-notes-list {
          list-style: none;
          padding: 0;
          margin: 0;
        }

        .related-notes-list li {
          margin-bottom: 0.75rem;
          padding-left: 1.5rem;
          position: relative;
        }

        .related-notes-list li::before {
          content: '→';
          position: absolute;
          left: 0;
          color: var(--bs-secondary);
        }

        .related-notes-list a {
          color: #1a1a1a !important;  /* Subtle, matches body text */
          text-decoration: none;
          transition: color 0.2s;
        }

        .related-notes-list a:hover {
          color: #20B2AA !important;  /* Teal on hover for interactivity */
          text-decoration: underline;
        }
        </style>

        <style>
        /* Back to top button */
        .back-to-top-btn {
          position: fixed;
          bottom: 2rem;
          right: 2rem;
          width: 48px;
          height: 48px;
          border-radius: 50%;
          background: var(--bs-body-bg);
          border: 1px solid var(--bs-border-color);
          color: var(--bs-body-color);
          font-size: 1.2rem;
          cursor: pointer;
          z-index: 999;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
          transition: all 0.3s ease;
          opacity: 0;
          visibility: hidden;
          transform: translateY(20px);
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .back-to-top-btn.visible {
          opacity: 1;
          visibility: visible;
          transform: translateY(0);
        }

        .back-to-top-btn:hover {
          background: var(--bs-primary);
          color: var(--bs-body-bg);
          border-color: var(--bs-primary);
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .back-to-top-btn:active {
          transform: translateY(0);
        }

        @media (max-width: 768px) {
          .back-to-top-btn {
            bottom: 1rem;
            right: 1rem;
            width: 44px;
            height: 44px;
            font-size: 1.1rem;
          }
        }

        /* Hide in print */
        @media print {
          .back-to-top-btn {
            display: none !important;
          }
        }
        </style>

        <style>
        /* Collapsible Code Blocks - Global */
        .code-block-wrapper {
          margin: 1.5rem 0;
          border: 1px solid var(--bs-border-color);
          border-radius: 0.5rem;
          background: #f8f8f8;
          overflow: hidden;
        }

        .code-block-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 0.5rem 1rem;
          background: #f0f0f0;
          border-bottom: 1px solid var(--bs-border-color);
          cursor: pointer;
          user-select: none;
          transition: background 0.2s ease;
        }

        .code-block-header:hover {
          background: #e8e8e8;
        }

        .code-block-title {
          font-family: "IBM Plex Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
          font-size: 0.85rem;
          font-weight: 500;
          color: #666;
          display: flex;
          align-items: center;
          gap: 0.5rem;
        }

        .code-block-toggle {
          font-size: 0.75rem;
          color: #666;
          transition: transform 0.2s ease;
          display: inline-block;
        }

        .code-block-wrapper.expanded .code-block-toggle {
          transform: rotate(180deg);
        }

        .code-block-content {
          display: none;
          overflow: hidden;
        }

        .code-block-wrapper.expanded .code-block-content {
          display: block;
        }

        .code-block-wrapper pre,
        .code-block-wrapper code {
          margin: 0;
          border-radius: 0;
        }

        /* Ensure outputs are always visible - never collapse them */
        .cell-output,
        .cell-output-stdout,
        .cell-output-stderr,
        .cell-output-display,
        .cell-output pre,
        .cell-output code {
          display: block !important;
          visibility: visible !important;
          opacity: 1 !important;
        }

        /* Ensure unwrapped code blocks are visible until JavaScript wraps them */
        pre.sourceCode:not(.code-block-wrapper pre.sourceCode),
        .cell-code:not(.code-block-wrapper .cell-code) {
          display: block !important;
        }
        </style>

        <script>
        (function() {
          // Function to wrap code blocks in collapsible structure
          // ONLY wrap input code blocks, NOT outputs
          function makeCodeBlocksCollapsible() {
            try {
            // Find only INPUT code blocks - exclude outputs
            // Target pre.sourceCode (standalone code blocks) and .cell-code (input code in cells)
            // Exclude ones already wrapped and exclude any inside .cell-output
            const codeBlocks = document.querySelectorAll('pre.sourceCode:not(.code-block-wrapper pre.sourceCode):not(.cell-output pre), .cell-code:not(.code-block-wrapper .cell-code):not(.cell-output .cell-code)');
            
            if (codeBlocks.length === 0) return;
            
            codeBlocks.forEach(function(block) {
              // Skip if already wrapped
              if (block.closest('.code-block-wrapper')) {
                return;
              }

              // Skip if inside output container
              if (block.closest('.cell-output, .cell-output-stdout, .cell-output-stderr, .cell-output-display')) {
                return;
              }

              // Skip inline code
              if (block.tagName === 'CODE' && block.parentElement && block.parentElement.tagName !== 'PRE') {
                return;
              }

              // Get language from class or parent
              let language = 'code';
              const classList = block.className || '';
              if (classList.includes('sourceCode')) {
                const match = classList.match(/sourceCode-(\w+)/);
                if (match) language = match[1];
              } else if (block.querySelector('code')) {
                const codeEl = block.querySelector('code');
                if (codeEl && codeEl.className) {
                  const match = codeEl.className.match(/language-(\w+)|sourceCode-(\w+)/);
                  if (match) language = match[1] || match[2];
                }
              }

              // Create wrapper
              const wrapper = document.createElement('div');
              wrapper.className = 'code-block-wrapper';

              // Create header
              const header = document.createElement('div');
              header.className = 'code-block-header';
              header.innerHTML = `
                <span class="code-block-title">
                  <span class="code-block-toggle">▼</span>
                  <span>${language}</span>
                </span>
              `;

              // Create content container
              const content = document.createElement('div');
              content.className = 'code-block-content';
              
              // Store parent and next sibling BEFORE moving block
              const parent = block.parentNode;
              const nextSibling = block.nextSibling;
              
              // Move the block into content (don't clone, move it)
              // This removes block from parent, so we need parent/nextSibling before this
              content.appendChild(block);

              // Assemble
              wrapper.appendChild(header);
              wrapper.appendChild(content);
              
              // Insert wrapper where block was
              // Note: block is now inside content, so we insert wrapper at block's old position
              if (parent) {
                // If there's a next sibling, insert before it (block was before nextSibling)
                // Otherwise append to end
                if (nextSibling && nextSibling.parentNode === parent) {
                  parent.insertBefore(wrapper, nextSibling);
                } else {
                  // If nextSibling is null or invalid, append to parent
                  parent.appendChild(wrapper);
                }
              }

              // Add click handler
              header.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                wrapper.classList.toggle('expanded');
              });
            });
            } catch (error) {
              console.error('Error in makeCodeBlocksCollapsible:', error);
              // Don't break the page if code block wrapping fails
            }
          }

          // Run when DOM is ready
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', makeCodeBlocksCollapsible);
          } else {
            // DOM already loaded
            makeCodeBlocksCollapsible();
          }

          // Also run after delays to catch dynamically loaded content
          setTimeout(makeCodeBlocksCollapsible, 100);
          setTimeout(makeCodeBlocksCollapsible, 500);
          setTimeout(makeCodeBlocksCollapsible, 1000);

          // Use MutationObserver to catch dynamically added code blocks
          const observer = new MutationObserver(function(mutations) {
            let shouldRun = false;
            mutations.forEach(function(mutation) {
              if (mutation.addedNodes.length > 0) {
                mutation.addedNodes.forEach(function(node) {
                  if (node.nodeType === 1) { // Element node
                    // Only trigger if it's an input code block, not an output
                    if (node.matches && (
                      (node.matches('pre.sourceCode') && !node.closest('.cell-output')) ||
                      (node.matches('.cell-code') && !node.closest('.cell-output')) ||
                      (node.querySelector && node.querySelector('pre.sourceCode:not(.cell-output pre), .cell-code:not(.cell-output .cell-code)'))
                    )) {
                      shouldRun = true;
                    }
                  }
                });
              }
            });
            if (shouldRun) {
              setTimeout(makeCodeBlocksCollapsible, 100);
            }
          });

          // Start observing
          if (document.body) {
            observer.observe(document.body, {
              childList: true,
              subtree: true
            });
          } else {
            document.addEventListener('DOMContentLoaded', function() {
              observer.observe(document.body, {
                childList: true,
                subtree: true
              });
            });
          }
        })();
        </script>

execute:
  eval: true
  echo: true
  warning: false
  error: true
  message: false
  freeze: auto
  cache: false

# Python execution configuration
# Use the conda environment's Python directly
python: /Users/timmwalker/miniforge3/envs/recurrent-analytics/bin/python
# Use python3 kernel (Quarto will use the python path above for execution)
jupyter: python3

# Blog-style collection with feed (RSS at notes/index.xml)
collections:
  notes:
    feed: true
    categories: true
    sort: "date desc"
    listing:
      type: default
      sort: "date desc"
      contents: "notes/*"
  projects:
    feed: false
    categories: true
    sort: "date desc"
    listing:
      type: default
      sort: "date desc"
      contents: "models/*"
